// Copyright © 2017-2021 Rémi Thebault
/// bindings to wayland-client-core.h
module wayland.native.client;

// Wayland client-core copyright:
/*
 * Copyright © 2008 Kristian Høgsberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import wayland.native.util;

extern (C) nothrow
{
    /** \class wl_proxy
    *
    * \brief Represents a protocol object on the client side.
    *
    * A wl_proxy acts as a client side proxy to an object existing in the
    * compositor. The proxy is responsible for converting requests made by the
    * clients with \ref wl_proxy_marshal() into Wayland's wire format. Events
    * coming from the compositor are also handled by the proxy, which will in
    * turn call the handler set with \ref wl_proxy_add_listener().
    *
    * \note With the exception of function \ref wl_proxy_set_queue(), functions
    * accessing a wl_proxy are not normally used by client code. Clients
    * should normally use the higher level iface generated by the scanner to
    * interact with compositor objects.
    *
    */
    struct wl_proxy;

    /** \class wl_display
    *
    * \brief Represents a connection to the compositor and acts as a proxy to
    * the wl_display singleton object.
    *
    * A wl_display object represents a client connection to a Wayland
    * compositor. It is created with either \ref wl_display_connect() or
    * \ref wl_display_connect_to_fd(). A connection is terminated using
    * \ref wl_display_disconnect().
    *
    * A wl_display is also used as the \ref wl_proxy for the wl_display
    * singleton object on the compositor side.
    *
    * A wl_display object handles all the data sent from and to the
    * compositor. When a \ref wl_proxy marshals a request, it will write its wire
    * representation to the display's write buffer. The data is sent to the
    * compositor when the client calls \ref wl_display_flush().
    *
    * Incoming data is handled in two steps: queueing and dispatching. In the
    * queue step, the data coming from the display fd is interpreted and
    * added to a queue. On the dispatch step, the handler for the incoming
    * event set by the client on the corresponding \ref wl_proxy is called.
    *
    * A wl_display has at least one event queue, called the <em>default
    * queue</em>. Clients can create additional event queues with \ref
    * wl_display_create_queue() and assign \ref wl_proxy's to it. Events
    * occurring in a particular proxy are always queued in its assigned queue.
    * A client can ensure that a certain assumption, such as holding a lock
    * or running from a given thread, is true when a proxy event handler is
    * called by assigning that proxy to an event queue and making sure that
    * this queue is only dispatched when the assumption holds.
    *
    * The default queue is dispatched by calling \ref wl_display_dispatch().
    * This will dispatch any events queued on the default queue and attempt
    * to read from the display fd if it's empty. Events read are then queued
    * on the appropriate queues according to the proxy assignment.
    *
    * A user created queue is dispatched with \ref wl_display_dispatch_queue().
    * This function behaves exactly the same as wl_display_dispatch()
    * but it dispatches given queue instead of the default queue.
    *
    * A real world example of event queue usage is Mesa's implementation of
    * eglSwapBuffers() for the Wayland platform. This function might need
    * to block until a frame callback is received, but dispatching the default
    * queue could cause an event handler on the client to start drawing
    * again. This problem is solved using another event queue, so that only
    * the events handled by the EGL code are dispatched during the block.
    *
    * This creates a problem where a thread dispatches a non-default
    * queue, reading all the data from the display fd. If the application
    * would call \em poll(2) after that it would block, even though there
    * might be events queued on the default queue. Those events should be
    * dispatched with \ref wl_display_dispatch_pending() or \ref
    * wl_display_dispatch_queue_pending() before flushing and blocking.
    */
    struct wl_display;

    /** \class wl_event_queue
    *
    * \brief A queue for \ref wl_proxy object events.
    *
    * Event queues allows the events on a display to be handled in a thread-safe
    * manner. See \ref wl_display for details.
    *
    */
    struct wl_event_queue;

    // used for wl_proxy_add_listener
    alias void_func_t = void function();
}

version (WlDynamic)
{
    extern (C) nothrow
    {
        alias da_wl_event_queue_destroy = void function(wl_event_queue* queue);

        alias da_wl_proxy_marshal = void function(wl_proxy* p, uint opcode, ...);

        alias da_wl_proxy_marshal_array = void function(wl_proxy* p, uint opcode, wl_argument* args);

        alias da_wl_proxy_create = wl_proxy* function(wl_proxy* factory, const(wl_interface)* iface);

        alias da_wl_proxy_create_wrapper = void* function(void* proxy);

        alias da_wl_proxy_wrapper_destroy = void function(void* proxy_wrapper);

        alias da_wl_proxy_marshal_constructor = wl_proxy* function(wl_proxy* proxy,
                uint opcode, const(wl_interface)* iface, ...);

        alias da_wl_proxy_marshal_constructor_versioned = wl_proxy* function(wl_proxy* proxy,
                uint opcode, const(wl_interface)* iface, uint ver, ...);

        alias da_wl_proxy_marshal_array_constructor = wl_proxy* function(wl_proxy* proxy,
                uint opcode, wl_argument* args, const(wl_interface)* iface);

        alias da_wl_proxy_marshal_array_constructor_versioned = wl_proxy* function(wl_proxy* proxy,
                uint opcode, wl_argument* args, const(wl_interface)* iface, uint ver);

        alias da_wl_proxy_destroy = void function(wl_proxy* proxy);

        alias da_wl_proxy_add_listener = int function(wl_proxy* proxy,
                void_func_t* impl, void* data);

        alias da_wl_proxy_get_listener = const(void)* function(wl_proxy* proxy);

        alias da_wl_proxy_add_dispatcher = int function(wl_proxy* proxy,
                wl_dispatcher_func_t dispatcher_func, const(void)* dispatcher_data, void* data);

        alias da_wl_proxy_set_user_data = void function(wl_proxy* proxy, void* user_data);

        alias da_wl_proxy_get_user_data = void* function(wl_proxy* proxy);

        alias da_wl_proxy_get_version = uint function(wl_proxy* proxy);

        alias da_wl_proxy_get_id = uint function(wl_proxy* proxy);

        alias da_wl_proxy_get_class = const(char)* function(wl_proxy* proxy);

        alias da_wl_proxy_set_queue = void function(wl_proxy* proxy, wl_event_queue* queue);

        alias da_wl_display_connect = wl_display* function(const(char)* name);

        alias da_wl_display_connect_to_fd = wl_display* function(int fd);

        alias da_wl_display_disconnect = void function(wl_display* display);

        alias da_wl_display_get_fd = int function(wl_display* display);

        alias da_wl_display_dispatch = int function(wl_display* display);

        alias da_wl_display_dispatch_queue = int function(wl_display* display,
                wl_event_queue* queue);

        alias da_wl_display_dispatch_queue_pending = int function(wl_display* display,
                wl_event_queue* queue);

        alias da_wl_display_dispatch_pending = int function(wl_display* display);

        alias da_wl_display_get_error = int function(wl_display* display);

        alias da_wl_display_get_protocol_error = uint function(wl_display* display,
                const(wl_interface)** iface, uint* id);

        alias da_wl_display_flush = int function(wl_display* display);

        alias da_wl_display_roundtrip_queue = int function(wl_display* display,
                wl_event_queue* queue);

        alias da_wl_display_roundtrip = int function(wl_display* display);

        alias da_wl_display_create_queue = wl_event_queue* function(wl_display* display);

        alias da_wl_display_prepare_read_queue = int function(wl_display* display,
                wl_event_queue* queue);

        alias da_wl_display_prepare_read = int function(wl_display* display);

        alias da_wl_display_cancel_read = void function(wl_display* display);

        alias da_wl_display_read_events = int function(wl_display* display);

        alias da_wl_log_set_handler_client = void function(wl_log_func_t handler);
    }

    __gshared
    {
        da_wl_event_queue_destroy wl_event_queue_destroy;

        da_wl_proxy_marshal wl_proxy_marshal;

        da_wl_proxy_marshal_array wl_proxy_marshal_array;

        da_wl_proxy_create wl_proxy_create;

        da_wl_proxy_create_wrapper wl_proxy_create_wrapper;

        da_wl_proxy_wrapper_destroy wl_proxy_wrapper_destroy;

        da_wl_proxy_marshal_constructor wl_proxy_marshal_constructor;

        da_wl_proxy_marshal_constructor_versioned wl_proxy_marshal_constructor_versioned;

        da_wl_proxy_marshal_array_constructor wl_proxy_marshal_array_constructor;

        da_wl_proxy_marshal_array_constructor_versioned wl_proxy_marshal_array_constructor_versioned;

        da_wl_proxy_destroy wl_proxy_destroy;

        da_wl_proxy_add_listener wl_proxy_add_listener;

        da_wl_proxy_get_listener wl_proxy_get_listener;

        da_wl_proxy_add_dispatcher wl_proxy_add_dispatcher;

        da_wl_proxy_set_user_data wl_proxy_set_user_data;

        da_wl_proxy_get_user_data wl_proxy_get_user_data;

        da_wl_proxy_get_version wl_proxy_get_version;

        da_wl_proxy_get_id wl_proxy_get_id;

        da_wl_proxy_get_class wl_proxy_get_class;

        da_wl_proxy_set_queue wl_proxy_set_queue;

        da_wl_display_connect wl_display_connect;

        da_wl_display_connect_to_fd wl_display_connect_to_fd;

        da_wl_display_disconnect wl_display_disconnect;

        da_wl_display_get_fd wl_display_get_fd;

        da_wl_display_dispatch wl_display_dispatch;

        da_wl_display_dispatch_queue wl_display_dispatch_queue;

        da_wl_display_dispatch_queue_pending wl_display_dispatch_queue_pending;

        da_wl_display_dispatch_pending wl_display_dispatch_pending;

        da_wl_display_get_error wl_display_get_error;

        da_wl_display_get_protocol_error wl_display_get_protocol_error;

        da_wl_display_flush wl_display_flush;

        da_wl_display_roundtrip_queue wl_display_roundtrip_queue;

        da_wl_display_roundtrip wl_display_roundtrip;

        da_wl_display_create_queue wl_display_create_queue;

        da_wl_display_prepare_read_queue wl_display_prepare_read_queue;

        da_wl_display_prepare_read wl_display_prepare_read;

        da_wl_display_cancel_read wl_display_cancel_read;

        da_wl_display_read_events wl_display_read_events;

        da_wl_log_set_handler_client wl_log_set_handler_client;
    }
}

version (WlStatic)
{
    extern (C) nothrow
    {
        void wl_event_queue_destroy(wl_event_queue* queue);

        void wl_proxy_marshal(wl_proxy* p, uint opcode, ...);

        void wl_proxy_marshal_array(wl_proxy* p, uint opcode, wl_argument* args);

        wl_proxy* wl_proxy_create(wl_proxy* factory, const(wl_interface)* iface);

        void* wl_proxy_create_wrapper(void* proxy);

        void wl_proxy_wrapper_destroy(void* proxy_wrapper);

        wl_proxy* wl_proxy_marshal_constructor(wl_proxy* proxy, uint opcode,
                const(wl_interface)* iface, ...);

        wl_proxy* wl_proxy_marshal_constructor_versioned(wl_proxy* proxy,
                uint opcode, const(wl_interface)* iface, uint ver, ...);

        wl_proxy* wl_proxy_marshal_array_constructor(wl_proxy* proxy,
                uint opcode, wl_argument* args, const(wl_interface)* iface);

        wl_proxy* wl_proxy_marshal_array_constructor_versioned(wl_proxy* proxy,
                uint opcode, wl_argument* args, const(wl_interface)* iface, uint ver);

        void wl_proxy_destroy(wl_proxy* proxy);

        int wl_proxy_add_listener(wl_proxy* proxy, void_func_t* impl, void* data);

        const(void)* wl_proxy_get_listener(wl_proxy* proxy);

        int wl_proxy_add_dispatcher(wl_proxy* proxy,
                wl_dispatcher_func_t dispatcher_func, const(void)* dispatcher_data, void* data);

        void wl_proxy_set_user_data(wl_proxy* proxy, void* user_data);

        void* wl_proxy_get_user_data(wl_proxy* proxy);

        uint wl_proxy_get_version(wl_proxy* proxy);

        uint wl_proxy_get_id(wl_proxy* proxy);

        const(char)* wl_proxy_get_class(wl_proxy* proxy);

        void wl_proxy_set_queue(wl_proxy* proxy, wl_event_queue* queue);

        wl_display* wl_display_connect(const(char)* name);

        wl_display* wl_display_connect_to_fd(int fd);

        void wl_display_disconnect(wl_display* display);

        int wl_display_get_fd(wl_display* display);

        int wl_display_dispatch(wl_display* display);

        int wl_display_dispatch_queue(wl_display* display, wl_event_queue* queue);

        int wl_display_dispatch_queue_pending(wl_display* display, wl_event_queue* queue);

        int wl_display_dispatch_pending(wl_display* display);

        int wl_display_get_error(wl_display* display);

        uint wl_display_get_protocol_error(wl_display* display,
                const(wl_interface)** iface, uint* id);

        int wl_display_flush(wl_display* display);

        int wl_display_roundtrip_queue(wl_display* display, wl_event_queue* queue);

        int wl_display_roundtrip(wl_display* display);

        wl_event_queue* wl_display_create_queue(wl_display* display);

        int wl_display_prepare_read_queue(wl_display* display, wl_event_queue* queue);

        int wl_display_prepare_read(wl_display* display);

        void wl_display_cancel_read(wl_display* display);

        int wl_display_read_events(wl_display* display);

        void wl_log_set_handler_client(wl_log_func_t handler);
    }
}
