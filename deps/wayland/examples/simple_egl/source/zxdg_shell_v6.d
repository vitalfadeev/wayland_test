/++
 +  Module generated by wayland:scanner-v0.3.1 for xdg_shell_unstable_v6 protocol
 +    xml protocol:   xdg-shell-unstable-v6.xml
 +    generated code: client
 +/
module zxdg_shell_v6;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2008-2013 Kristian Høgsberg
 +  Copyright © 2013      Rafael Antognolli
 +  Copyright © 2013      Jasper St. Pierre
 +  Copyright © 2010-2013 Intel Corporation
 +
 +  Permission is hereby granted, free of charge, to any person obtaining a
 +  copy of this software and associated documentation files (the "Software"),
 +  to deal in the Software without restriction, including without limitation
 +  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 +  and/or sell copies of the Software, and to permit persons to whom the
 +  Software is furnished to do so, subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the next
 +  paragraph) shall be included in all copies or substantial portions of the
 +  Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 +  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 +  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 +  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 +  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 +  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 +  DEALINGS IN THE SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  create desktop-style surfaces
 +
 +  xdg_shell allows clients to turn a wl_surface into a "real window"
 +  which can be dragged, resized, stacked, and moved around by the
 +  user. Everything about this interface is suited towards traditional
 +  desktop environments.
 +/
final class ZxdgShellV6 : WlProxy
{
    /// Version of xdg_shell_unstable_v6.zxdg_shell_v6
    enum ver = 1;

    /// Build a ZxdgShellV6 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_zxdg_shell_v6_listener, null);
    }

    /// Interface object that creates ZxdgShellV6 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return zxdgShellV6Iface;
    }

    /// Op-code of ZxdgShellV6.destroy.
    enum destroyOpCode = 0;
    /// Op-code of ZxdgShellV6.createPositioner.
    enum createPositionerOpCode = 1;
    /// Op-code of ZxdgShellV6.getXdgSurface.
    enum getXdgSurfaceOpCode = 2;
    /// Op-code of ZxdgShellV6.pong.
    enum pongOpCode = 3;

    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgShellV6.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgShellV6.createPositioner.
    enum createPositionerSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgShellV6.getXdgSurface.
    enum getXdgSurfaceSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgShellV6.pong.
    enum pongSinceVersion = 1;

    /// xdg_shell_unstable_v6 protocol version introducing ZxdgShellV6.onPing.
    enum onPingSinceVersion = 1;

    /// Event delegate signature of ZxdgShellV6.onPing.
    alias OnPingEventDg = void delegate(ZxdgShellV6 zxdgShellV6,
                                        uint serial);

    enum Error : uint
    {
        /// given wl_surface has another role
        role = 0,
        /// xdg_shell was destroyed before children
        defunctSurfaces = 1,
        /// the client tried to map or destroy a non-topmost popup
        notTheTopmostPopup = 2,
        /// the client specified an invalid popup parent surface
        invalidPopupParent = 3,
        /// the client provided an invalid surface state
        invalidSurfaceState = 4,
        /// the client provided an invalid positioner
        invalidPositioner = 5,
    }

    /++
     +  destroy xdg_shell
     +
     +  Destroy this xdg_shell object.
     +
     +  Destroying a bound xdg_shell object while there are surfaces
     +  still alive created by this xdg_shell object instance is illegal
     +  and will result in a protocol error.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  create a positioner object
     +
     +  Create a positioner object. A positioner object is used to position
     +  surfaces relative to some parent surface. See the interface description
     +  and xdg_surface.get_popup for details.
     +/
    ZxdgPositionerV6 createPositioner()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createPositionerOpCode, ZxdgPositionerV6.iface.native, null
        );
        if (!_pp) return null;
        auto _p = WlProxy.get(_pp);
        if (_p) return cast(ZxdgPositionerV6)_p;
        return new ZxdgPositionerV6(_pp);
    }

    /++
     +  create a shell surface from a surface
     +
     +  This creates an xdg_surface for the given surface. While xdg_surface
     +  itself is not a role, the corresponding surface may only be assigned
     +  a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
     +
     +  This creates an xdg_surface for the given surface. An xdg_surface is
     +  used as basis to define a role to a given surface, such as xdg_toplevel
     +  or xdg_popup. It also manages functionality shared between xdg_surface
     +  based surface roles.
     +
     +  See the documentation of xdg_surface for more details about what an
     +  xdg_surface is and how it is used.
     +/
    ZxdgSurfaceV6 getXdgSurface(WlSurface surface)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getXdgSurfaceOpCode, ZxdgSurfaceV6.iface.native, null,
            surface.proxy
        );
        if (!_pp) return null;
        auto _p = WlProxy.get(_pp);
        if (_p) return cast(ZxdgSurfaceV6)_p;
        return new ZxdgSurfaceV6(_pp);
    }

    /++
     +  respond to a ping event
     +
     +  A client must respond to a ping event with a pong request or
     +  the client may be deemed unresponsive. See xdg_shell.ping.
     +/
    void pong(uint serial)
    {
        wl_proxy_marshal(
            proxy, pongOpCode, serial
        );
    }

    /++
     +  check if the client is alive
     +
     +  The ping event asks the client if it's still alive. Pass the
     +  serial specified in the event back to the compositor by sending
     +  a "pong" request back with the specified serial. See xdg_shell.ping.
     +
     +  Compositors can use this to determine if the client is still
     +  alive. It's unspecified what will happen if the client doesn't
     +  respond to the ping request, or in what timeframe. Clients should
     +  try to respond in a reasonable amount of time.
     +
     +  A compositor is free to ping in any way it wants, but a client must
     +  always respond to any xdg_shell object it created.
     +/
    @property void onPing(OnPingEventDg dg)
    {
        _onPing = dg;
    }

    private OnPingEventDg _onPing;
}

/++
 +  child surface positioner
 +
 +  The xdg_positioner provides a collection of rules for the placement of a
 +  child surface relative to a parent surface. Rules can be defined to ensure
 +  the child surface remains within the visible area's borders, and to
 +  specify how the child surface changes its position, such as sliding along
 +  an axis, or flipping around a rectangle. These positioner-created rules are
 +  constrained by the requirement that a child surface must intersect with or
 +  be at least partially adjacent to its parent surface.
 +
 +  See the various requests for details about possible rules.
 +
 +  At the time of the request, the compositor makes a copy of the rules
 +  specified by the xdg_positioner. Thus, after the request is complete the
 +  xdg_positioner object can be destroyed or reused; further changes to the
 +  object will have no effect on previous usages.
 +
 +  For an xdg_positioner object to be considered complete, it must have a
 +  non-zero size set by set_size, and a non-zero anchor rectangle set by
 +  set_anchor_rect. Passing an incomplete xdg_positioner object when
 +  positioning a surface raises an error.
 +/
final class ZxdgPositionerV6 : WlProxy
{
    /// Version of xdg_shell_unstable_v6.zxdg_positioner_v6
    enum ver = 1;

    /// Build a ZxdgPositionerV6 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates ZxdgPositionerV6 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return zxdgPositionerV6Iface;
    }

    /// Op-code of ZxdgPositionerV6.destroy.
    enum destroyOpCode = 0;
    /// Op-code of ZxdgPositionerV6.setSize.
    enum setSizeOpCode = 1;
    /// Op-code of ZxdgPositionerV6.setAnchorRect.
    enum setAnchorRectOpCode = 2;
    /// Op-code of ZxdgPositionerV6.setAnchor.
    enum setAnchorOpCode = 3;
    /// Op-code of ZxdgPositionerV6.setGravity.
    enum setGravityOpCode = 4;
    /// Op-code of ZxdgPositionerV6.setConstraintAdjustment.
    enum setConstraintAdjustmentOpCode = 5;
    /// Op-code of ZxdgPositionerV6.setOffset.
    enum setOffsetOpCode = 6;

    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setSize.
    enum setSizeSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setAnchorRect.
    enum setAnchorRectSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setAnchor.
    enum setAnchorSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setGravity.
    enum setGravitySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setConstraintAdjustment.
    enum setConstraintAdjustmentSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPositionerV6.setOffset.
    enum setOffsetSinceVersion = 1;

    enum Error : uint
    {
        /// invalid input provided
        invalidInput = 0,
    }

    enum Anchor : uint
    {
        /// the center of the anchor rectangle
        none = 0,
        /// the top edge of the anchor rectangle
        top = 1,
        /// the bottom edge of the anchor rectangle
        bottom = 2,
        /// the left edge of the anchor rectangle
        left = 4,
        /// the right edge of the anchor rectangle
        right = 8,
    }

    enum Gravity : uint
    {
        /// center over the anchor edge
        none = 0,
        /// position above the anchor edge
        top = 1,
        /// position below the anchor edge
        bottom = 2,
        /// position to the left of the anchor edge
        left = 4,
        /// position to the right of the anchor edge
        right = 8,
    }

    /++
     +  constraint adjustments
     +
     +  The constraint adjustment value define ways the compositor will adjust
     +  the position of the surface, if the unadjusted position would result
     +  in the surface being partly constrained.
     +
     +  Whether a surface is considered 'constrained' is left to the compositor
     +  to determine. For example, the surface may be partly outside the
     +  compositor's defined 'work area', thus necessitating the child surface's
     +  position be adjusted until it is entirely inside the work area.
     +
     +  The adjustments can be combined, according to a defined precedence: 1$(RPAREN)
     +  Flip, 2$(RPAREN) Slide, 3$(RPAREN) Resize.
     +/
    enum ConstraintAdjustment : uint
    {
        none = 0,
        slideX = 1,
        slideY = 2,
        flipX = 4,
        flipY = 8,
        resizeX = 16,
        resizeY = 32,
    }

    /++
     +  destroy the xdg_positioner object
     +
     +  Notify the compositor that the xdg_positioner will no longer be used.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the size of the to-be positioned rectangle
     +
     +  Set the size of the surface that is to be positioned with the positioner
     +  object. The size is in surface-local coordinates and corresponds to the
     +  window geometry. See xdg_surface.set_window_geometry.
     +
     +  If a zero or negative size is set the invalid_input error is raised.
     +/
    void setSize(int width,
                 int height)
    {
        wl_proxy_marshal(
            proxy, setSizeOpCode, width, height
        );
    }

    /++
     +  set the anchor rectangle within the parent surface
     +
     +  Specify the anchor rectangle within the parent surface that the child
     +  surface will be placed relative to. The rectangle is relative to the
     +  window geometry as defined by xdg_surface.set_window_geometry of the
     +  parent surface. The rectangle must be at least 1x1 large.
     +
     +  When the xdg_positioner object is used to position a child surface, the
     +  anchor rectangle may not extend outside the window geometry of the
     +  positioned child's parent surface.
     +
     +  If a zero or negative size is set the invalid_input error is raised.
     +/
    void setAnchorRect(int x,
                       int y,
                       int width,
                       int height)
    {
        wl_proxy_marshal(
            proxy, setAnchorRectOpCode, x, y, width, height
        );
    }

    /++
     +  set anchor rectangle anchor edges
     +
     +  Defines a set of edges for the anchor rectangle. These are used to
     +  derive an anchor point that the child surface will be positioned
     +  relative to. If two orthogonal edges are specified $(LPAREN)e.g. 'top' and
     +  'left'$(RPAREN), then the anchor point will be the intersection of the edges
     +  $(LPAREN)e.g. the top left position of the rectangle$(RPAREN); otherwise, the derived
     +  anchor point will be centered on the specified edge, or in the center of
     +  the anchor rectangle if no edge is specified.
     +
     +  If two parallel anchor edges are specified $(LPAREN)e.g. 'left' and 'right'$(RPAREN),
     +  the invalid_input error is raised.
     +/
    void setAnchor(Anchor anchor)
    {
        wl_proxy_marshal(
            proxy, setAnchorOpCode, anchor
        );
    }

    /++
     +  set child surface gravity
     +
     +  Defines in what direction a surface should be positioned, relative to
     +  the anchor point of the parent surface. If two orthogonal gravities are
     +  specified $(LPAREN)e.g. 'bottom' and 'right'$(RPAREN), then the child surface will be
     +  placed in the specified direction; otherwise, the child surface will be
     +  centered over the anchor point on any axis that had no gravity
     +  specified.
     +
     +  If two parallel gravities are specified $(LPAREN)e.g. 'left' and 'right'$(RPAREN), the
     +  invalid_input error is raised.
     +/
    void setGravity(Gravity gravity)
    {
        wl_proxy_marshal(
            proxy, setGravityOpCode, gravity
        );
    }

    /++
     +  set the adjustment to be done when constrained
     +
     +  Specify how the window should be positioned if the originally intended
     +  position caused the surface to be constrained, meaning at least
     +  partially outside positioning boundaries set by the compositor. The
     +  adjustment is set by constructing a bitmask describing the adjustment to
     +  be made when the surface is constrained on that axis.
     +
     +  If no bit for one axis is set, the compositor will assume that the child
     +  surface should not change its position on that axis when constrained.
     +
     +  If more than one bit for one axis is set, the order of how adjustments
     +  are applied is specified in the corresponding adjustment descriptions.
     +
     +  The default adjustment is none.
     +/
    void setConstraintAdjustment(uint constraintAdjustment)
    {
        wl_proxy_marshal(
            proxy, setConstraintAdjustmentOpCode, constraintAdjustment
        );
    }

    /++
     +  set surface position offset
     +
     +  Specify the surface position offset relative to the position of the
     +  anchor on the anchor rectangle and the anchor on the surface. For
     +  example if the anchor of the anchor rectangle is at $(LPAREN)x, y$(RPAREN), the surface
     +  has the gravity bottom|right, and the offset is $(LPAREN)ox, oy$(RPAREN), the calculated
     +  surface position will be $(LPAREN)x + ox, y + oy$(RPAREN). The offset position of the
     +  surface is the one used for constraint testing. See
     +  set_constraint_adjustment.
     +
     +  An example use case is placing a popup menu on top of a user interface
     +  element, while aligning the user interface element of the parent surface
     +  with some user interface element placed somewhere in the popup surface.
     +/
    void setOffset(int x,
                   int y)
    {
        wl_proxy_marshal(
            proxy, setOffsetOpCode, x, y
        );
    }
}

/++
 +  desktop user interface surface base interface
 +
 +  An interface that may be implemented by a wl_surface, for
 +  implementations that provide a desktop-style user interface.
 +
 +  It provides a base set of functionality required to construct user
 +  interface elements requiring management by the compositor, such as
 +  toplevel windows, menus, etc. The types of functionality are split into
 +  xdg_surface roles.
 +
 +  Creating an xdg_surface does not set the role for a wl_surface. In order
 +  to map an xdg_surface, the client must create a role-specific object
 +  using, e.g., get_toplevel, get_popup. The wl_surface for any given
 +  xdg_surface can have at most one role, and may not be assigned any role
 +  not based on xdg_surface.
 +
 +  A role must be assigned before any other requests are made to the
 +  xdg_surface object.
 +
 +  The client must call wl_surface.commit on the corresponding wl_surface
 +  for the xdg_surface state to take effect.
 +
 +  Creating an xdg_surface from a wl_surface which has a buffer attached or
 +  committed is a client error, and any attempts by a client to attach or
 +  manipulate a buffer prior to the first xdg_surface.configure call must
 +  also be treated as errors.
 +
 +  For a surface to be mapped by the compositor, the following conditions
 +  must be met: $(LPAREN)1$(RPAREN) the client has assigned a xdg_surface based role to the
 +  surface, $(LPAREN)2$(RPAREN) the client has set and committed the xdg_surface state and
 +  the role dependent state to the surface and $(LPAREN)3$(RPAREN) the client has committed a
 +  buffer to the surface.
 +/
final class ZxdgSurfaceV6 : WlProxy
{
    /// Version of xdg_shell_unstable_v6.zxdg_surface_v6
    enum ver = 1;

    /// Build a ZxdgSurfaceV6 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_zxdg_surface_v6_listener, null);
    }

    /// Interface object that creates ZxdgSurfaceV6 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return zxdgSurfaceV6Iface;
    }

    /// Op-code of ZxdgSurfaceV6.destroy.
    enum destroyOpCode = 0;
    /// Op-code of ZxdgSurfaceV6.getToplevel.
    enum getToplevelOpCode = 1;
    /// Op-code of ZxdgSurfaceV6.getPopup.
    enum getPopupOpCode = 2;
    /// Op-code of ZxdgSurfaceV6.setWindowGeometry.
    enum setWindowGeometryOpCode = 3;
    /// Op-code of ZxdgSurfaceV6.ackConfigure.
    enum ackConfigureOpCode = 4;

    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgSurfaceV6.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgSurfaceV6.getToplevel.
    enum getToplevelSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgSurfaceV6.getPopup.
    enum getPopupSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgSurfaceV6.setWindowGeometry.
    enum setWindowGeometrySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgSurfaceV6.ackConfigure.
    enum ackConfigureSinceVersion = 1;

    /// xdg_shell_unstable_v6 protocol version introducing ZxdgSurfaceV6.onConfigure.
    enum onConfigureSinceVersion = 1;

    /// Event delegate signature of ZxdgSurfaceV6.onConfigure.
    alias OnConfigureEventDg = void delegate(ZxdgSurfaceV6 zxdgSurfaceV6,
                                             uint serial);

    enum Error : uint
    {
        notConstructed = 1,
        alreadyConstructed = 2,
        unconfiguredBuffer = 3,
    }

    /++
     +  destroy the xdg_surface
     +
     +  Destroy the xdg_surface object. An xdg_surface must only be destroyed
     +  after its role object has been destroyed.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  assign the xdg_toplevel surface role
     +
     +  This creates an xdg_toplevel object for the given xdg_surface and gives
     +  the associated wl_surface the xdg_toplevel role.
     +
     +  See the documentation of xdg_toplevel for more details about what an
     +  xdg_toplevel is and how it is used.
     +/
    ZxdgToplevelV6 getToplevel()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getToplevelOpCode, ZxdgToplevelV6.iface.native, null
        );
        if (!_pp) return null;
        auto _p = WlProxy.get(_pp);
        if (_p) return cast(ZxdgToplevelV6)_p;
        return new ZxdgToplevelV6(_pp);
    }

    /++
     +  assign the xdg_popup surface role
     +
     +  This creates an xdg_popup object for the given xdg_surface and gives the
     +  associated wl_surface the xdg_popup role.
     +
     +  See the documentation of xdg_popup for more details about what an
     +  xdg_popup is and how it is used.
     +/
    ZxdgPopupV6 getPopup(ZxdgSurfaceV6 parent,
                         ZxdgPositionerV6 positioner)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getPopupOpCode, ZxdgPopupV6.iface.native, null, parent.proxy,
            positioner.proxy
        );
        if (!_pp) return null;
        auto _p = WlProxy.get(_pp);
        if (_p) return cast(ZxdgPopupV6)_p;
        return new ZxdgPopupV6(_pp);
    }

    /++
     +  set the new window geometry
     +
     +  The window geometry of a surface is its "visible bounds" from the
     +  user's perspective. Client-side decorations often have invisible
     +  portions like drop-shadows which should be ignored for the
     +  purposes of aligning, placing and constraining windows.
     +
     +  The window geometry is double buffered, and will be applied at the
     +  time wl_surface.commit of the corresponding wl_surface is called.
     +
     +  Once the window geometry of the surface is set, it is not possible to
     +  unset it, and it will remain the same until set_window_geometry is
     +  called again, even if a new subsurface or buffer is attached.
     +
     +  If never set, the value is the full bounds of the surface,
     +  including any subsurfaces. This updates dynamically on every
     +  commit. This unset is meant for extremely simple clients.
     +
     +  The arguments are given in the surface-local coordinate space of
     +  the wl_surface associated with this xdg_surface.
     +
     +  The width and height must be greater than zero. Setting an invalid size
     +  will raise an error. When applied, the effective window geometry will be
     +  the set window geometry clamped to the bounding rectangle of the
     +  combined geometry of the surface of the xdg_surface and the associated
     +  subsurfaces.
     +/
    void setWindowGeometry(int x,
                           int y,
                           int width,
                           int height)
    {
        wl_proxy_marshal(
            proxy, setWindowGeometryOpCode, x, y, width, height
        );
    }

    /++
     +  ack a configure event
     +
     +  When a configure event is received, if a client commits the
     +  surface in response to the configure event, then the client
     +  must make an ack_configure request sometime before the commit
     +  request, passing along the serial of the configure event.
     +
     +  For instance, for toplevel surfaces the compositor might use this
     +  information to move a surface to the top left only when the client has
     +  drawn itself for the maximized or fullscreen state.
     +
     +  If the client receives multiple configure events before it
     +  can respond to one, it only has to ack the last configure event.
     +
     +  A client is not required to commit immediately after sending
     +  an ack_configure request - it may even ack_configure several times
     +  before its next surface commit.
     +
     +  A client may send multiple ack_configure requests before committing, but
     +  only the last request sent before a commit indicates which configure
     +  event the client really is responding to.
     +/
    void ackConfigure(uint serial)
    {
        wl_proxy_marshal(
            proxy, ackConfigureOpCode, serial
        );
    }

    /++
     +  suggest a surface change
     +
     +  The configure event marks the end of a configure sequence. A configure
     +  sequence is a set of one or more events configuring the state of the
     +  xdg_surface, including the final xdg_surface.configure event.
     +
     +  Where applicable, xdg_surface surface roles will during a configure
     +  sequence extend this event as a latched state sent as events before the
     +  xdg_surface.configure event. Such events should be considered to make up
     +  a set of atomically applied configuration states, where the
     +  xdg_surface.configure commits the accumulated state.
     +
     +  Clients should arrange their surface for the new states, and then send
     +  an ack_configure request with the serial sent in this configure event at
     +  some point before committing the new surface.
     +
     +  If the client receives multiple configure events before it can respond
     +  to one, it is free to discard all but the last event it received.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    private OnConfigureEventDg _onConfigure;
}

/++
 +  toplevel surface
 +
 +  This interface defines an xdg_surface role which allows a surface to,
 +  among other things, set window-like properties such as maximize,
 +  fullscreen, and minimize, set application-specific metadata like title and
 +  id, and well as trigger user interactive operations such as interactive
 +  resize and move.
 +/
final class ZxdgToplevelV6 : WlProxy
{
    /// Version of xdg_shell_unstable_v6.zxdg_toplevel_v6
    enum ver = 1;

    /// Build a ZxdgToplevelV6 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_zxdg_toplevel_v6_listener, null);
    }

    /// Interface object that creates ZxdgToplevelV6 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return zxdgToplevelV6Iface;
    }

    /// Op-code of ZxdgToplevelV6.destroy.
    enum destroyOpCode = 0;
    /// Op-code of ZxdgToplevelV6.setParent.
    enum setParentOpCode = 1;
    /// Op-code of ZxdgToplevelV6.setTitle.
    enum setTitleOpCode = 2;
    /// Op-code of ZxdgToplevelV6.setAppId.
    enum setAppIdOpCode = 3;
    /// Op-code of ZxdgToplevelV6.showWindowMenu.
    enum showWindowMenuOpCode = 4;
    /// Op-code of ZxdgToplevelV6.move.
    enum moveOpCode = 5;
    /// Op-code of ZxdgToplevelV6.resize.
    enum resizeOpCode = 6;
    /// Op-code of ZxdgToplevelV6.setMaxSize.
    enum setMaxSizeOpCode = 7;
    /// Op-code of ZxdgToplevelV6.setMinSize.
    enum setMinSizeOpCode = 8;
    /// Op-code of ZxdgToplevelV6.setMaximized.
    enum setMaximizedOpCode = 9;
    /// Op-code of ZxdgToplevelV6.unsetMaximized.
    enum unsetMaximizedOpCode = 10;
    /// Op-code of ZxdgToplevelV6.setFullscreen.
    enum setFullscreenOpCode = 11;
    /// Op-code of ZxdgToplevelV6.unsetFullscreen.
    enum unsetFullscreenOpCode = 12;
    /// Op-code of ZxdgToplevelV6.setMinimized.
    enum setMinimizedOpCode = 13;

    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setParent.
    enum setParentSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setTitle.
    enum setTitleSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setAppId.
    enum setAppIdSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.showWindowMenu.
    enum showWindowMenuSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.move.
    enum moveSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.resize.
    enum resizeSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setMaxSize.
    enum setMaxSizeSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setMinSize.
    enum setMinSizeSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setMaximized.
    enum setMaximizedSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.unsetMaximized.
    enum unsetMaximizedSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setFullscreen.
    enum setFullscreenSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.unsetFullscreen.
    enum unsetFullscreenSinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgToplevelV6.setMinimized.
    enum setMinimizedSinceVersion = 1;

    /// xdg_shell_unstable_v6 protocol version introducing ZxdgToplevelV6.onConfigure.
    enum onConfigureSinceVersion = 1;
    /// xdg_shell_unstable_v6 protocol version introducing ZxdgToplevelV6.onClose.
    enum onCloseSinceVersion = 1;

    /// Event delegate signature of ZxdgToplevelV6.onConfigure.
    alias OnConfigureEventDg = void delegate(ZxdgToplevelV6 zxdgToplevelV6,
                                             int width,
                                             int height,
                                             wl_array* states);
    /// Event delegate signature of ZxdgToplevelV6.onClose.
    alias OnCloseEventDg = void delegate(ZxdgToplevelV6 zxdgToplevelV6);

    /++
     +  edge values for resizing
     +
     +  These values are used to indicate which edge of a surface
     +  is being dragged in a resize operation.
     +/
    enum ResizeEdge : uint
    {
        none = 0,
        top = 1,
        bottom = 2,
        left = 4,
        topLeft = 5,
        bottomLeft = 6,
        right = 8,
        topRight = 9,
        bottomRight = 10,
    }

    /++
     +  types of state on the surface
     +
     +  The different state values used on the surface. This is designed for
     +  state values like maximized, fullscreen. It is paired with the
     +  configure event to ensure that both the client and the compositor
     +  setting the state can be synchronized.
     +
     +  States set in this way are double-buffered. They will get applied on
     +  the next commit.
     +/
    enum State : uint
    {
        /// the surface is maximized
        maximized = 1,
        /// the surface is fullscreen
        fullscreen = 2,
        /// the surface is being resized
        resizing = 3,
        /// the surface is now activated
        activated = 4,
    }

    /++
     +  destroy the xdg_toplevel
     +
     +  Unmap and destroy the window. The window will be effectively
     +  hidden from the user's point of view, and all state like
     +  maximization, fullscreen, and so on, will be lost.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the parent of this surface
     +
     +  Set the "parent" of this surface. This window should be stacked
     +  above a parent. The parent surface must be mapped as long as this
     +  surface is mapped.
     +
     +  Parent windows should be set on dialogs, toolboxes, or other
     +  "auxiliary" surfaces, so that the parent is raised when the dialog
     +  is raised.
     +/
    void setParent(ZxdgToplevelV6 parent)
    {
        wl_proxy_marshal(
            proxy, setParentOpCode, parent.proxy
        );
    }

    /++
     +  set surface title
     +
     +  Set a short title for the surface.
     +
     +  This string may be used to identify the surface in a task bar,
     +  window list, or other user interface elements provided by the
     +  compositor.
     +
     +  The string must be encoded in UTF-8.
     +/
    void setTitle(string title)
    {
        wl_proxy_marshal(
            proxy, setTitleOpCode, toStringz(title)
        );
    }

    /++
     +  set application ID
     +
     +  Set an application identifier for the surface.
     +
     +  The app ID identifies the general class of applications to which
     +  the surface belongs. The compositor can use this to group multiple
     +  surfaces together, or to determine how to launch a new application.
     +
     +  For D-Bus activatable applications, the app ID is used as the D-Bus
     +  service name.
     +
     +  The compositor shell will try to group application surfaces together
     +  by their app ID. As a best practice, it is suggested to select app
     +  ID's that match the basename of the application's .desktop file.
     +  For example, "org.freedesktop.FooViewer" where the .desktop file is
     +  "org.freedesktop.FooViewer.desktop".
     +
     +  See the desktop-entry specification [0] for more details on
     +  application identifiers and how they relate to well-known D-Bus
     +  names and .desktop files.
     +
     +  [0] http://standards.freedesktop.org/desktop-entry-spec/
     +/
    void setAppId(string appId)
    {
        wl_proxy_marshal(
            proxy, setAppIdOpCode, toStringz(appId)
        );
    }

    /++
     +  show the window menu
     +
     +  Clients implementing client-side decorations might want to show
     +  a context menu when right-clicking on the decorations, giving the
     +  user a menu that they can use to maximize or minimize the window.
     +
     +  This request asks the compositor to pop up such a window menu at
     +  the given position, relative to the local surface coordinates of
     +  the parent surface. There are no guarantees as to what menu items
     +  the window menu contains.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event.
     +/
    void showWindowMenu(WlSeat seat,
                        uint serial,
                        int x,
                        int y)
    {
        wl_proxy_marshal(
            proxy, showWindowMenuOpCode, seat.proxy, serial, x, y
        );
    }

    /++
     +  start an interactive move
     +
     +  Start an interactive, user-driven move of the surface.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event. The passed
     +  serial is used to determine the type of interactive move $(LPAREN)touch,
     +  pointer, etc$(RPAREN).
     +
     +  The server may ignore move requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN), or if the passed serial
     +  is no longer valid.
     +
     +  If triggered, the surface will lose the focus of the device
     +  $(LPAREN)wl_pointer, wl_touch, etc$(RPAREN) used for the move. It is up to the
     +  compositor to visually indicate that the move is taking place, such as
     +  updating a pointer cursor, during the move. There is no guarantee
     +  that the device focus will return when the move is completed.
     +/
    void move(WlSeat seat,
              uint serial)
    {
        wl_proxy_marshal(
            proxy, moveOpCode, seat.proxy, serial
        );
    }

    /++
     +  start an interactive resize
     +
     +  Start a user-driven, interactive resize of the surface.
     +
     +  This request must be used in response to some sort of user action
     +  like a button press, key press, or touch down event. The passed
     +  serial is used to determine the type of interactive resize $(LPAREN)touch,
     +  pointer, etc$(RPAREN).
     +
     +  The server may ignore resize requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN).
     +
     +  If triggered, the client will receive configure events with the
     +  "resize" state enum value and the expected sizes. See the "resize"
     +  enum value for more details about what is required. The client
     +  must also acknowledge configure events using "ack_configure". After
     +  the resize is completed, the client will receive another "configure"
     +  event without the resize state.
     +
     +  If triggered, the surface also will lose the focus of the device
     +  $(LPAREN)wl_pointer, wl_touch, etc$(RPAREN) used for the resize. It is up to the
     +  compositor to visually indicate that the resize is taking place,
     +  such as updating a pointer cursor, during the resize. There is no
     +  guarantee that the device focus will return when the resize is
     +  completed.
     +
     +  The edges parameter specifies how the surface should be resized,
     +  and is one of the values of the resize_edge enum. The compositor
     +  may use this information to update the surface position for
     +  example when dragging the top left corner. The compositor may also
     +  use this information to adapt its behavior, e.g. choose an
     +  appropriate cursor image.
     +/
    void resize(WlSeat seat,
                uint serial,
                uint edges)
    {
        wl_proxy_marshal(
            proxy, resizeOpCode, seat.proxy, serial, edges
        );
    }

    /++
     +  set the maximum size
     +
     +  Set a maximum size for the window.
     +
     +  The client can specify a maximum size so that the compositor does
     +  not try to configure the window beyond this size.
     +
     +  The width and height arguments are in window geometry coordinates.
     +  See xdg_surface.set_window_geometry.
     +
     +  Values set in this way are double-buffered. They will get applied
     +  on the next commit.
     +
     +  The compositor can use this information to allow or disallow
     +  different states like maximize or fullscreen and draw accurate
     +  animations.
     +
     +  Similarly, a tiling window manager may use this information to
     +  place and resize client windows in a more effective way.
     +
     +  The client should not rely on the compositor to obey the maximum
     +  size. The compositor may decide to ignore the values set by the
     +  client and request a larger size.
     +
     +  If never set, or a value of zero in the request, means that the
     +  client has no expected maximum size in the given dimension.
     +  As a result, a client wishing to reset the maximum size
     +  to an unspecified state can use zero for width and height in the
     +  request.
     +
     +  Requesting a maximum size to be smaller than the minimum size of
     +  a surface is illegal and will result in a protocol error.
     +
     +  The width and height must be greater than or equal to zero. Using
     +  strictly negative values for width and height will result in a
     +  protocol error.
     +/
    void setMaxSize(int width,
                    int height)
    {
        wl_proxy_marshal(
            proxy, setMaxSizeOpCode, width, height
        );
    }

    /++
     +  set the minimum size
     +
     +  Set a minimum size for the window.
     +
     +  The client can specify a minimum size so that the compositor does
     +  not try to configure the window below this size.
     +
     +  The width and height arguments are in window geometry coordinates.
     +  See xdg_surface.set_window_geometry.
     +
     +  Values set in this way are double-buffered. They will get applied
     +  on the next commit.
     +
     +  The compositor can use this information to allow or disallow
     +  different states like maximize or fullscreen and draw accurate
     +  animations.
     +
     +  Similarly, a tiling window manager may use this information to
     +  place and resize client windows in a more effective way.
     +
     +  The client should not rely on the compositor to obey the minimum
     +  size. The compositor may decide to ignore the values set by the
     +  client and request a smaller size.
     +
     +  If never set, or a value of zero in the request, means that the
     +  client has no expected minimum size in the given dimension.
     +  As a result, a client wishing to reset the minimum size
     +  to an unspecified state can use zero for width and height in the
     +  request.
     +
     +  Requesting a minimum size to be larger than the maximum size of
     +  a surface is illegal and will result in a protocol error.
     +
     +  The width and height must be greater than or equal to zero. Using
     +  strictly negative values for width and height will result in a
     +  protocol error.
     +/
    void setMinSize(int width,
                    int height)
    {
        wl_proxy_marshal(
            proxy, setMinSizeOpCode, width, height
        );
    }

    /++
     +  maximize the window
     +
     +  Maximize the surface.
     +
     +  After requesting that the surface should be maximized, the compositor
     +  will respond by emitting a configure event with the "maximized" state
     +  and the required window geometry. The client should then update its
     +  content, drawing it in a maximized state, i.e. without shadow or other
     +  decoration outside of the window geometry. The client must also
     +  acknowledge the configure when committing the new content $(LPAREN)see
     +  ack_configure$(RPAREN).
     +
     +  It is up to the compositor to decide how and where to maximize the
     +  surface, for example which output and what region of the screen should
     +  be used.
     +
     +  If the surface was already maximized, the compositor will still emit
     +  a configure event with the "maximized" state.
     +/
    void setMaximized()
    {
        wl_proxy_marshal(
            proxy, setMaximizedOpCode
        );
    }

    /++
     +  unmaximize the window
     +
     +  Unmaximize the surface.
     +
     +  After requesting that the surface should be unmaximized, the compositor
     +  will respond by emitting a configure event without the "maximized"
     +  state. If available, the compositor will include the window geometry
     +  dimensions the window had prior to being maximized in the configure
     +  request. The client must then update its content, drawing it in a
     +  regular state, i.e. potentially with shadow, etc. The client must also
     +  acknowledge the configure when committing the new content $(LPAREN)see
     +  ack_configure$(RPAREN).
     +
     +  It is up to the compositor to position the surface after it was
     +  unmaximized; usually the position the surface had before maximizing, if
     +  applicable.
     +
     +  If the surface was already not maximized, the compositor will still
     +  emit a configure event without the "maximized" state.
     +/
    void unsetMaximized()
    {
        wl_proxy_marshal(
            proxy, unsetMaximizedOpCode
        );
    }

    /++
     +  set the window as fullscreen on a monitor
     +
     +  Make the surface fullscreen.
     +
     +  You can specify an output that you would prefer to be fullscreen.
     +  If this value is NULL, it's up to the compositor to choose which
     +  display will be used to map this surface.
     +
     +  If the surface doesn't cover the whole output, the compositor will
     +  position the surface in the center of the output and compensate with
     +  black borders filling the rest of the output.
     +/
    void setFullscreen(WlOutput output)
    {
        wl_proxy_marshal(
            proxy, setFullscreenOpCode, output.proxy
        );
    }

    void unsetFullscreen()
    {
        wl_proxy_marshal(
            proxy, unsetFullscreenOpCode
        );
    }

    /++
     +  set the window as minimized
     +
     +  Request that the compositor minimize your surface. There is no
     +  way to know if the surface is currently minimized, nor is there
     +  any way to unset minimization on this surface.
     +
     +  If you are looking to throttle redrawing when minimized, please
     +  instead use the wl_surface.frame event for this, as this will
     +  also work with live previews on windows in Alt-Tab, Expose or
     +  similar compositor features.
     +/
    void setMinimized()
    {
        wl_proxy_marshal(
            proxy, setMinimizedOpCode
        );
    }

    /++
     +  suggest a surface change
     +
     +  This configure event asks the client to resize its toplevel surface or
     +  to change its state. The configured state should not be applied
     +  immediately. See xdg_surface.configure for details.
     +
     +  The width and height arguments specify a hint to the window
     +  about how its surface should be resized in window geometry
     +  coordinates. See set_window_geometry.
     +
     +  If the width or height arguments are zero, it means the client
     +  should decide its own window dimension. This may happen when the
     +  compositor needs to configure the state of the surface but doesn't
     +  have any information about any previous or expected dimension.
     +
     +  The states listed in the event specify how the width/height
     +  arguments should be interpreted, and possibly how it should be
     +  drawn.
     +
     +  Clients must send an ack_configure in response to this event. See
     +  xdg_surface.configure and xdg_surface.ack_configure for details.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    /++
     +  surface wants to be closed
     +
     +  The close event is sent by the compositor when the user
     +  wants the surface to be closed. This should be equivalent to
     +  the user clicking the close button in client-side decorations,
     +  if your application has any.
     +
     +  This is only a request that the user intends to close the
     +  window. The client may choose to ignore this request, or show
     +  a dialog to ask the user to save their data, etc.
     +/
    @property void onClose(OnCloseEventDg dg)
    {
        _onClose = dg;
    }

    private OnConfigureEventDg _onConfigure;
    private OnCloseEventDg _onClose;
}

/++
 +  short-lived, popup surfaces for menus
 +
 +  A popup surface is a short-lived, temporary surface. It can be used to
 +  implement for example menus, popovers, tooltips and other similar user
 +  interface concepts.
 +
 +  A popup can be made to take an explicit grab. See xdg_popup.grab for
 +  details.
 +
 +  When the popup is dismissed, a popup_done event will be sent out, and at
 +  the same time the surface will be unmapped. See the xdg_popup.popup_done
 +  event for details.
 +
 +  Explicitly destroying the xdg_popup object will also dismiss the popup and
 +  unmap the surface. Clients that want to dismiss the popup when another
 +  surface of their own is clicked should dismiss the popup using the destroy
 +  request.
 +
 +  The parent surface must have either the xdg_toplevel or xdg_popup surface
 +  role.
 +
 +  A newly created xdg_popup will be stacked on top of all previously created
 +  xdg_popup surfaces associated with the same xdg_toplevel.
 +
 +  The parent of an xdg_popup must be mapped $(LPAREN)see the xdg_surface
 +  description$(RPAREN) before the xdg_popup itself.
 +
 +  The x and y arguments passed when creating the popup object specify
 +  where the top left of the popup should be placed, relative to the
 +  local surface coordinates of the parent surface. See
 +  xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 +  partially adjacent to its parent surface.
 +
 +  The client must call wl_surface.commit on the corresponding wl_surface
 +  for the xdg_popup state to take effect.
 +/
final class ZxdgPopupV6 : WlProxy
{
    /// Version of xdg_shell_unstable_v6.zxdg_popup_v6
    enum ver = 1;

    /// Build a ZxdgPopupV6 from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_zxdg_popup_v6_listener, null);
    }

    /// Interface object that creates ZxdgPopupV6 objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return zxdgPopupV6Iface;
    }

    /// Op-code of ZxdgPopupV6.destroy.
    enum destroyOpCode = 0;
    /// Op-code of ZxdgPopupV6.grab.
    enum grabOpCode = 1;

    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPopupV6.destroy.
    enum destroySinceVersion = 1;
    /// Version of xdg_shell_unstable_v6 protocol introducing ZxdgPopupV6.grab.
    enum grabSinceVersion = 1;

    /// xdg_shell_unstable_v6 protocol version introducing ZxdgPopupV6.onConfigure.
    enum onConfigureSinceVersion = 1;
    /// xdg_shell_unstable_v6 protocol version introducing ZxdgPopupV6.onPopupDone.
    enum onPopupDoneSinceVersion = 1;

    /// Event delegate signature of ZxdgPopupV6.onConfigure.
    alias OnConfigureEventDg = void delegate(ZxdgPopupV6 zxdgPopupV6,
                                             int x,
                                             int y,
                                             int width,
                                             int height);
    /// Event delegate signature of ZxdgPopupV6.onPopupDone.
    alias OnPopupDoneEventDg = void delegate(ZxdgPopupV6 zxdgPopupV6);

    enum Error : uint
    {
        /// tried to grab after being mapped
        invalidGrab = 0,
    }

    /++
     +  remove xdg_popup interface
     +
     +  This destroys the popup. Explicitly destroying the xdg_popup
     +  object will also dismiss the popup, and unmap the surface.
     +
     +  If this xdg_popup is not the "topmost" popup, a protocol error
     +  will be sent.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  make the popup take an explicit grab
     +
     +  This request makes the created popup take an explicit grab. An explicit
     +  grab will be dismissed when the user dismisses the popup, or when the
     +  client destroys the xdg_popup. This can be done by the user clicking
     +  outside the surface, using the keyboard, or even locking the screen
     +  through closing the lid or a timeout.
     +
     +  If the compositor denies the grab, the popup will be immediately
     +  dismissed.
     +
     +  This request must be used in response to some sort of user action like a
     +  button press, key press, or touch down event. The serial number of the
     +  event should be passed as 'serial'.
     +
     +  The parent of a grabbing popup must either be an xdg_toplevel surface or
     +  another xdg_popup with an explicit grab. If the parent is another
     +  xdg_popup it means that the popups are nested, with this popup now being
     +  the topmost popup.
     +
     +  Nested popups must be destroyed in the reverse order they were created
     +  in, e.g. the only popup you are allowed to destroy at all times is the
     +  topmost one.
     +
     +  When compositors choose to dismiss a popup, they may dismiss every
     +  nested grabbing popup as well. When a compositor dismisses popups, it
     +  will follow the same dismissing order as required from the client.
     +
     +  The parent of a grabbing popup must either be another xdg_popup with an
     +  active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
     +  explicit grabs already taken.
     +
     +  If the topmost grabbing popup is destroyed, the grab will be returned to
     +  the parent of the popup, if that parent previously had an explicit grab.
     +
     +  If the parent is a grabbing popup which has already been dismissed, this
     +  popup will be immediately dismissed. If the parent is a popup that did
     +  not take an explicit grab, an error will be raised.
     +
     +  During a popup grab, the client owning the grab will receive pointer
     +  and touch events for all their surfaces as normal $(LPAREN)similar to an
     +  "owner-events" grab in X11 parlance$(RPAREN), while the top most grabbing popup
     +  will always have keyboard focus.
     +/
    void grab(WlSeat seat,
              uint serial)
    {
        wl_proxy_marshal(
            proxy, grabOpCode, seat.proxy, serial
        );
    }

    /++
     +  configure the popup surface
     +
     +  This event asks the popup surface to configure itself given the
     +  configuration. The configured state should not be applied immediately.
     +  See xdg_surface.configure for details.
     +
     +  The x and y arguments represent the position the popup was placed at
     +  given the xdg_positioner rule, relative to the upper left corner of the
     +  window geometry of the parent surface.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    /++
     +  popup interaction is done
     +
     +  The popup_done event is sent out when a popup is dismissed by the
     +  compositor. The client should destroy the xdg_popup object at this
     +  point.
     +/
    @property void onPopupDone(OnPopupDoneEventDg dg)
    {
        _onPopupDone = dg;
    }

    private OnConfigureEventDg _onConfigure;
    private OnPopupDoneEventDg _onPopupDone;
}

private:

immutable WlProxyInterface zxdgShellV6Iface;
immutable WlProxyInterface zxdgPositionerV6Iface;
immutable WlProxyInterface zxdgSurfaceV6Iface;
immutable WlProxyInterface zxdgToplevelV6Iface;
immutable WlProxyInterface zxdgPopupV6Iface;

immutable final class ZxdgShellV6Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new ZxdgShellV6(proxy);
    }
}

immutable final class ZxdgPositionerV6Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new ZxdgPositionerV6(proxy);
    }
}

immutable final class ZxdgSurfaceV6Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new ZxdgSurfaceV6(proxy);
    }
}

immutable final class ZxdgToplevelV6Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new ZxdgToplevelV6(proxy);
    }
}

immutable final class ZxdgPopupV6Iface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new ZxdgPopupV6(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum zxdgShellV6Index = 0;
enum zxdgPositionerV6Index = 1;
enum zxdgSurfaceV6Index = 2;
enum zxdgToplevelV6Index = 3;
enum zxdgPopupV6Index = 4;

shared static this()
{
    auto ifaces = new wl_interface[5];

    auto msgTypes = [
        null,
        null,
        null,
        null,
        &ifaces[zxdgPositionerV6Index],
        &ifaces[zxdgSurfaceV6Index],
        cast(wl_interface*)WlSurface.iface.native,
        &ifaces[zxdgToplevelV6Index],
        &ifaces[zxdgPopupV6Index],
        &ifaces[zxdgSurfaceV6Index],
        &ifaces[zxdgPositionerV6Index],
        &ifaces[zxdgToplevelV6Index],
        cast(wl_interface*)WlSeat.iface.native,
        null,
        null,
        null,
        cast(wl_interface*)WlSeat.iface.native,
        null,
        cast(wl_interface*)WlSeat.iface.native,
        null,
        null,
        cast(wl_interface*)WlOutput.iface.native,
        cast(wl_interface*)WlSeat.iface.native,
        null,
    ];

    auto zxdg_shell_v6_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("create_positioner", "n", &msgTypes[4]),
        wl_message("get_xdg_surface", "no", &msgTypes[5]),
        wl_message("pong", "u", &msgTypes[0]),
    ];
    auto zxdg_shell_v6_events = [
        wl_message("ping", "u", &msgTypes[0]),
    ];
    ifaces[zxdgShellV6Index].name = "zxdg_shell_v6";
    ifaces[zxdgShellV6Index].version_ = 1;
    ifaces[zxdgShellV6Index].method_count = 4;
    ifaces[zxdgShellV6Index].methods = zxdg_shell_v6_requests.ptr;
    ifaces[zxdgShellV6Index].event_count = 1;
    ifaces[zxdgShellV6Index].events = zxdg_shell_v6_events.ptr;

    auto zxdg_positioner_v6_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_size", "ii", &msgTypes[0]),
        wl_message("set_anchor_rect", "iiii", &msgTypes[0]),
        wl_message("set_anchor", "u", &msgTypes[0]),
        wl_message("set_gravity", "u", &msgTypes[0]),
        wl_message("set_constraint_adjustment", "u", &msgTypes[0]),
        wl_message("set_offset", "ii", &msgTypes[0]),
    ];
    ifaces[zxdgPositionerV6Index].name = "zxdg_positioner_v6";
    ifaces[zxdgPositionerV6Index].version_ = 1;
    ifaces[zxdgPositionerV6Index].method_count = 7;
    ifaces[zxdgPositionerV6Index].methods = zxdg_positioner_v6_requests.ptr;

    auto zxdg_surface_v6_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_toplevel", "n", &msgTypes[7]),
        wl_message("get_popup", "noo", &msgTypes[8]),
        wl_message("set_window_geometry", "iiii", &msgTypes[0]),
        wl_message("ack_configure", "u", &msgTypes[0]),
    ];
    auto zxdg_surface_v6_events = [
        wl_message("configure", "u", &msgTypes[0]),
    ];
    ifaces[zxdgSurfaceV6Index].name = "zxdg_surface_v6";
    ifaces[zxdgSurfaceV6Index].version_ = 1;
    ifaces[zxdgSurfaceV6Index].method_count = 5;
    ifaces[zxdgSurfaceV6Index].methods = zxdg_surface_v6_requests.ptr;
    ifaces[zxdgSurfaceV6Index].event_count = 1;
    ifaces[zxdgSurfaceV6Index].events = zxdg_surface_v6_events.ptr;

    auto zxdg_toplevel_v6_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_parent", "?o", &msgTypes[11]),
        wl_message("set_title", "s", &msgTypes[0]),
        wl_message("set_app_id", "s", &msgTypes[0]),
        wl_message("show_window_menu", "ouii", &msgTypes[12]),
        wl_message("move", "ou", &msgTypes[16]),
        wl_message("resize", "ouu", &msgTypes[18]),
        wl_message("set_max_size", "ii", &msgTypes[0]),
        wl_message("set_min_size", "ii", &msgTypes[0]),
        wl_message("set_maximized", "", &msgTypes[0]),
        wl_message("unset_maximized", "", &msgTypes[0]),
        wl_message("set_fullscreen", "?o", &msgTypes[21]),
        wl_message("unset_fullscreen", "", &msgTypes[0]),
        wl_message("set_minimized", "", &msgTypes[0]),
    ];
    auto zxdg_toplevel_v6_events = [
        wl_message("configure", "iia", &msgTypes[0]),
        wl_message("close", "", &msgTypes[0]),
    ];
    ifaces[zxdgToplevelV6Index].name = "zxdg_toplevel_v6";
    ifaces[zxdgToplevelV6Index].version_ = 1;
    ifaces[zxdgToplevelV6Index].method_count = 14;
    ifaces[zxdgToplevelV6Index].methods = zxdg_toplevel_v6_requests.ptr;
    ifaces[zxdgToplevelV6Index].event_count = 2;
    ifaces[zxdgToplevelV6Index].events = zxdg_toplevel_v6_events.ptr;

    auto zxdg_popup_v6_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("grab", "ou", &msgTypes[22]),
    ];
    auto zxdg_popup_v6_events = [
        wl_message("configure", "iiii", &msgTypes[0]),
        wl_message("popup_done", "", &msgTypes[0]),
    ];
    ifaces[zxdgPopupV6Index].name = "zxdg_popup_v6";
    ifaces[zxdgPopupV6Index].version_ = 1;
    ifaces[zxdgPopupV6Index].method_count = 2;
    ifaces[zxdgPopupV6Index].methods = zxdg_popup_v6_requests.ptr;
    ifaces[zxdgPopupV6Index].event_count = 2;
    ifaces[zxdgPopupV6Index].events = zxdg_popup_v6_events.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    zxdgShellV6Iface = new immutable ZxdgShellV6Iface( &wl_ifaces[zxdgShellV6Index] );
    zxdgPositionerV6Iface = new immutable ZxdgPositionerV6Iface( &wl_ifaces[zxdgPositionerV6Index] );
    zxdgSurfaceV6Iface = new immutable ZxdgSurfaceV6Iface( &wl_ifaces[zxdgSurfaceV6Index] );
    zxdgToplevelV6Iface = new immutable ZxdgToplevelV6Iface( &wl_ifaces[zxdgToplevelV6Index] );
    zxdgPopupV6Iface = new immutable ZxdgPopupV6Iface( &wl_ifaces[zxdgPopupV6Index] );
}

extern(C) nothrow
{
    struct zxdg_shell_v6_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial) ping;
    }

    __gshared wl_d_zxdg_shell_v6_listener = zxdg_shell_v6_listener (&wl_d_on_zxdg_shell_v6_ping);

    void wl_d_on_zxdg_shell_v6_ping(void* data,
                                    wl_proxy* proxy,
                                    uint serial)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgShellV6)_p;
            assert(_i, "listener stub proxy is not ZxdgShellV6");
            if (_i._onPing)
            {
                _i._onPing(_i, serial);
            }
        });
    }


    struct zxdg_surface_v6_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial) configure;
    }

    __gshared wl_d_zxdg_surface_v6_listener = zxdg_surface_v6_listener (&wl_d_on_zxdg_surface_v6_configure);

    void wl_d_on_zxdg_surface_v6_configure(void* data,
                                           wl_proxy* proxy,
                                           uint serial)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgSurfaceV6)_p;
            assert(_i, "listener stub proxy is not ZxdgSurfaceV6");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, serial);
            }
        });
    }

    struct zxdg_toplevel_v6_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int width,
                      int height,
                      wl_array* states) configure;
        void function(void* data,
                      wl_proxy* proxy) close;
    }

    __gshared wl_d_zxdg_toplevel_v6_listener = zxdg_toplevel_v6_listener (&wl_d_on_zxdg_toplevel_v6_configure,
                                                                          &wl_d_on_zxdg_toplevel_v6_close);

    void wl_d_on_zxdg_toplevel_v6_configure(void* data,
                                            wl_proxy* proxy,
                                            int width,
                                            int height,
                                            wl_array* states)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgToplevelV6)_p;
            assert(_i, "listener stub proxy is not ZxdgToplevelV6");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, width, height, states);
            }
        });
    }

    void wl_d_on_zxdg_toplevel_v6_close(void* data,
                                        wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgToplevelV6)_p;
            assert(_i, "listener stub proxy is not ZxdgToplevelV6");
            if (_i._onClose)
            {
                _i._onClose(_i);
            }
        });
    }

    struct zxdg_popup_v6_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int x,
                      int y,
                      int width,
                      int height) configure;
        void function(void* data,
                      wl_proxy* proxy) popup_done;
    }

    __gshared wl_d_zxdg_popup_v6_listener = zxdg_popup_v6_listener (&wl_d_on_zxdg_popup_v6_configure,
                                                                    &wl_d_on_zxdg_popup_v6_popup_done);

    void wl_d_on_zxdg_popup_v6_configure(void* data,
                                         wl_proxy* proxy,
                                         int x,
                                         int y,
                                         int width,
                                         int height)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgPopupV6)_p;
            assert(_i, "listener stub proxy is not ZxdgPopupV6");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, x, y, width, height);
            }
        });
    }

    void wl_d_on_zxdg_popup_v6_popup_done(void* data,
                                          wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = WlProxy.get(proxy);
            assert(_p, "listener stub without proxy");
            auto _i = cast(ZxdgPopupV6)_p;
            assert(_i, "listener stub proxy is not ZxdgPopupV6");
            if (_i._onPopupDone)
            {
                _i._onPopupDone(_i);
            }
        });
    }
}
