/++
 +  Module generated by wayland:scanner-v0.3.1 for wayland protocol
 +    xml protocol:   wayland.xml
 +    generated code: client
 +/
module wwwwww;
/+
 +  Protocol copyright:
 +
 +  Copyright © 2008-2011 Kristian Høgsberg
 +  Copyright © 2010-2011 Intel Corporation
 +  Copyright © 2012-2013 Collabora, Ltd.
 +
 +  Permission is hereby granted, free of charge, to any person
 +  obtaining a copy of this software and associated documentation files
 +  (the "Software"), to deal in the Software without restriction,
 +  including without limitation the rights to use, copy, modify, merge,
 +  publish, distribute, sublicense, and/or sell copies of the Software,
 +  and to permit persons to whom the Software is furnished to do so,
 +  subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the
 +  next paragraph) shall be included in all copies or substantial
 +  portions of the Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 +  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 +  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 +  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 +  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 +  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 +  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 +  SOFTWARE.
 +/
/+
 +  Bindings copyright:
 +
 +  Copyright © 2017-2019 Rémi Thebault
 +/
import wayland.client.core;
import wayland.native.client;
import wayland.native.util;
import wayland.util;

import std.exception : enforce;
import std.string : fromStringz, toStringz;

/++
 +  core global object
 +
 +  The core global object.  This is a special singleton object.  It
 +  is used for internal Wayland protocol features.
 +/
final class WlDisplay : WlDisplayBase
{
    /// Version of wayland.wl_display
    enum ver = 1;

    /// Build a WlDisplay from a native object.
    package(wayland) this(wl_display* native)
    {
        super(native);
    }

    /// Interface object that creates WlDisplay objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlDisplayIface;
    }

    /// Op-code of WlDisplay.sync.
    enum syncOpCode = 0;
    /// Op-code of WlDisplay.getRegistry.
    enum getRegistryOpCode = 1;

    /// Version of wayland protocol introducing WlDisplay.sync.
    enum syncSinceVersion = 1;
    /// Version of wayland protocol introducing WlDisplay.getRegistry.
    enum getRegistrySinceVersion = 1;

    /// wayland protocol version introducing WlDisplay.onError.
    enum onErrorSinceVersion = 1;
    /// wayland protocol version introducing WlDisplay.onDeleteId.
    enum onDeleteIdSinceVersion = 1;

    /++
     +  global error values
     +
     +  These errors are global and can be emitted in response to any
     +  server request.
     +/
    enum Error : uint
    {
        /// server couldn't find object
        invalidObject = 0,
        /// method doesn't exist on the specified interface or malformed request
        invalidMethod = 1,
        /// server is out of memory
        noMemory = 2,
        /// implementation error in compositor
        implementation = 3,
    }

    /++
     +  asynchronous roundtrip
     +
     +  The sync request asks the server to emit the 'done' event
     +  on the returned wl_callback object.  Since requests are
     +  handled in-order and events are delivered in-order, this can
     +  be used as a barrier to ensure all previous requests and the
     +  resulting events have been handled.
     +
     +  The object returned by this request will be destroyed by the
     +  compositor after the callback is fired and as such the client must not
     +  attempt to use it after that point.
     +
     +  The callback_data passed in the callback is undefined and should be ignored.
     +/
    WlCallback sync()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, syncOpCode, WlCallback.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlCallback)_p;
        return new WlCallback(_pp);
    }

    /++
     +  get global registry object
     +
     +  This request creates a registry object that allows the client
     +  to list and bind the global objects available from the
     +  compositor.
     +
     +  It should be noted that the server side resources consumed in
     +  response to a get_registry request can only be released when the
     +  client disconnects, not when the client side proxy is destroyed.
     +  Therefore, clients should invoke get_registry as infrequently as
     +  possible to avoid wasting memory.
     +/
    WlRegistry getRegistry()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getRegistryOpCode, WlRegistry.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlRegistry)_p;
        return new WlRegistry(_pp);
    }
}

/++
 +  global registry object
 +
 +  The singleton global registry object.  The server has a number of
 +  global objects that are available to all clients.  These objects
 +  typically represent an actual object in the server $(LPAREN)for example,
 +  an input device$(RPAREN) or they are singleton objects that provide
 +  extension functionality.
 +
 +  When a client creates a registry object, the registry object
 +  will emit a global event for each global currently in the
 +  registry.  Globals come and go as a result of device or
 +  monitor hotplugs, reconfiguration or other events, and the
 +  registry will send out global and global_remove events to
 +  keep the client up to date with the changes.  To mark the end
 +  of the initial burst of events, the client can use the
 +  wl_display.sync request immediately after calling
 +  wl_display.get_registry.
 +
 +  A client can bind to a global object by using the bind
 +  request.  This creates a client-side handle that lets the object
 +  emit events to the client and lets the client invoke requests on
 +  the object.
 +/
final class WlRegistry : WlProxy
{
    /// Version of wayland.wl_registry
    enum ver = 1;

    /// Build a WlRegistry from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_registry_listener, cast(void*) this);
    }

    /// Interface object that creates WlRegistry objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlRegistryIface;
    }

    /// Op-code of WlRegistry.bind.
    enum bindOpCode = 0;

    /// Version of wayland protocol introducing WlRegistry.bind.
    enum bindSinceVersion = 1;

    /// wayland protocol version introducing WlRegistry.onGlobal.
    enum onGlobalSinceVersion = 1;
    /// wayland protocol version introducing WlRegistry.onGlobalRemove.
    enum onGlobalRemoveSinceVersion = 1;

    /// Event delegate signature of WlRegistry.onGlobal.
    alias OnGlobalEventDg = void delegate(WlRegistry wlRegistry,
                                          uint name,
                                          string iface,
                                          uint version_);
    /// Event delegate signature of WlRegistry.onGlobalRemove.
    alias OnGlobalRemoveEventDg = void delegate(WlRegistry wlRegistry,
                                                uint name);

    /// Destroy this WlRegistry object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  bind an object to the display
     +
     +  Binds a new, client-created object to the server using the
     +  specified name as the identifier.
     +/
    WlProxy bind(uint name,
                 immutable(WlProxyInterface) iface,
                 uint ver)
    {
        auto _pp = wl_proxy_marshal_constructor_versioned(
            proxy, bindOpCode, iface.native, ver, name, iface.native.name, ver
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlProxy)_p;
        return iface.makeProxy(_pp);
    }

    /++
     +  announce global object
     +
     +  Notify the client of global objects.
     +
     +  The event notifies the client that a global object with
     +  the given name is now available, and it implements the
     +  given version of the given interface.
     +/
    @property void onGlobal(OnGlobalEventDg dg)
    {
        _onGlobal = dg;
    }

    /++
     +  announce removal of global object
     +
     +  Notify the client of removed global objects.
     +
     +  This event notifies the client that the global identified
     +  by name is no longer available.  If the client bound to
     +  the global using the bind request, the client should now
     +  destroy that object.
     +
     +  The object remains valid and requests to the object will be
     +  ignored until the client destroys it, to avoid races between
     +  the global going away and a client sending a request to it.
     +/
    @property void onGlobalRemove(OnGlobalRemoveEventDg dg)
    {
        _onGlobalRemove = dg;
    }

    private OnGlobalEventDg _onGlobal;
    private OnGlobalRemoveEventDg _onGlobalRemove;
}

/++
 +  callback object
 +
 +  Clients can handle the 'done' event to get notified when
 +  the related request is done.
 +
 +  Note, because wl_callback objects are created from multiple independent
 +  factory interfaces, the wl_callback interface is frozen at version 1.
 +/
final class WlCallback : WlProxy
{
    /// Version of wayland.wl_callback
    enum ver = 1;

    /// Build a WlCallback from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_callback_listener, cast(void*) this);
    }

    /// Interface object that creates WlCallback objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlCallbackIface;
    }

    /// wayland protocol version introducing WlCallback.onDone.
    enum onDoneSinceVersion = 1;

    /// Event delegate signature of WlCallback.onDone.
    alias OnDoneEventDg = void delegate(WlCallback wlCallback,
                                        uint callbackData);

    /// Destroy this WlCallback object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  done event
     +
     +  Notify the client when the related request is done.
     +/
    @property void onDone(OnDoneEventDg dg)
    {
        _onDone = dg;
    }

    private OnDoneEventDg _onDone;
}

/++
 +  the compositor singleton
 +
 +  A compositor.  This object is a singleton global.  The
 +  compositor is in charge of combining the contents of multiple
 +  surfaces into one displayable output.
 +/
final class WlCompositor : WlProxy
{
    /// Version of wayland.wl_compositor
    enum ver = 6;

    /// Build a WlCompositor from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlCompositor objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlCompositorIface;
    }

    /// Op-code of WlCompositor.createSurface.
    enum createSurfaceOpCode = 0;
    /// Op-code of WlCompositor.createRegion.
    enum createRegionOpCode = 1;

    /// Version of wayland protocol introducing WlCompositor.createSurface.
    enum createSurfaceSinceVersion = 1;
    /// Version of wayland protocol introducing WlCompositor.createRegion.
    enum createRegionSinceVersion = 1;

    /// Destroy this WlCompositor object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  create new surface
     +
     +  Ask the compositor to create a new surface.
     +/
    WlSurface createSurface()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createSurfaceOpCode, WlSurface.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlSurface)_p;
        return new WlSurface(_pp);
    }

    /++
     +  create new region
     +
     +  Ask the compositor to create a new region.
     +/
    WlRegion createRegion()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createRegionOpCode, WlRegion.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlRegion)_p;
        return new WlRegion(_pp);
    }
}

/++
 +  a shared memory pool
 +
 +  The wl_shm_pool object encapsulates a piece of memory shared
 +  between the compositor and client.  Through the wl_shm_pool
 +  object, the client can allocate shared memory wl_buffer objects.
 +  All objects created through the same pool share the same
 +  underlying mapped memory. Reusing the mapped memory avoids the
 +  setup/teardown overhead and is useful when interactively resizing
 +  a surface or for many small buffers.
 +/
final class WlShmPool : WlProxy
{
    /// Version of wayland.wl_shm_pool
    enum ver = 2;

    /// Build a WlShmPool from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlShmPool objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlShmPoolIface;
    }

    /// Op-code of WlShmPool.createBuffer.
    enum createBufferOpCode = 0;
    /// Op-code of WlShmPool.destroy.
    enum destroyOpCode = 1;
    /// Op-code of WlShmPool.resize.
    enum resizeOpCode = 2;

    /// Version of wayland protocol introducing WlShmPool.createBuffer.
    enum createBufferSinceVersion = 1;
    /// Version of wayland protocol introducing WlShmPool.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlShmPool.resize.
    enum resizeSinceVersion = 1;

    /++
     +  create a buffer from the pool
     +
     +  Create a wl_buffer object from the pool.
     +
     +  The buffer is created offset bytes into the pool and has
     +  width and height as specified.  The stride argument specifies
     +  the number of bytes from the beginning of one row to the beginning
     +  of the next.  The format is the pixel format of the buffer and
     +  must be one of those advertised through the wl_shm.format event.
     +
     +  A buffer will keep a reference to the pool it was created from
     +  so it is valid to destroy the pool immediately after creating
     +  a buffer from it.
     +/
    WlBuffer createBuffer(int offset,
                          int width,
                          int height,
                          int stride,
                          WlShm.Format format)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createBufferOpCode, WlBuffer.iface.native, null, offset, width,
            height, stride, format
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlBuffer)_p;
        return new WlBuffer(_pp);
    }

    /++
     +  destroy the pool
     +
     +  Destroy the shared memory pool.
     +
     +  The mmapped memory will be released when all
     +  buffers that have been created from this pool
     +  are gone.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  change the size of the pool mapping
     +
     +  This request will cause the server to remap the backing memory
     +  for the pool from the file descriptor passed when the pool was
     +  created, but using the new size.  This request can only be
     +  used to make the pool bigger.
     +
     +  This request only changes the amount of bytes that are mmapped
     +  by the server and does not touch the file corresponding to the
     +  file descriptor passed at creation time. It is the client's
     +  responsibility to ensure that the file is at least as big as
     +  the new pool size.
     +/
    void resize(int size)
    {
        wl_proxy_marshal(
            proxy, resizeOpCode, size
        );
    }
}

/++
 +  shared memory support
 +
 +  A singleton global object that provides support for shared
 +  memory.
 +
 +  Clients can create wl_shm_pool objects using the create_pool
 +  request.
 +
 +  On binding the wl_shm object one or more format events
 +  are emitted to inform clients about the valid pixel formats
 +  that can be used for buffers.
 +/
final class WlShm : WlProxy
{
    /// Version of wayland.wl_shm
    enum ver = 2;

    /// Build a WlShm from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_shm_listener, cast(void*) this);
    }

    /// Interface object that creates WlShm objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlShmIface;
    }

    /// Op-code of WlShm.createPool.
    enum createPoolOpCode = 0;
    /// Op-code of WlShm.release.
    enum releaseOpCode = 1;

    /// Version of wayland protocol introducing WlShm.createPool.
    enum createPoolSinceVersion = 1;
    /// Version of wayland protocol introducing WlShm.release.
    enum releaseSinceVersion = 2;

    /// wayland protocol version introducing WlShm.onFormat.
    enum onFormatSinceVersion = 1;

    /// Event delegate signature of WlShm.onFormat.
    alias OnFormatEventDg = void delegate(WlShm wlShm,
                                          Format format);

    /++
     +  wl_shm error values
     +
     +  These errors can be emitted in response to wl_shm requests.
     +/
    enum Error : uint
    {
        /// buffer format is not known
        invalidFormat = 0,
        /// invalid size or stride during pool or buffer creation
        invalidStride = 1,
        /// mmapping the file descriptor failed
        invalidFd = 2,
    }

    /++
     +  pixel formats
     +
     +  This describes the memory layout of an individual pixel.
     +
     +  All renderers should support argb8888 and xrgb8888 but any other
     +  formats are optional and may not be supported by the particular
     +  renderer in use.
     +
     +  The drm format codes match the macros defined in drm_fourcc.h, except
     +  argb8888 and xrgb8888. The formats actually supported by the compositor
     +  will be reported by the format event.
     +
     +  For all wl_shm formats and unless specified in another protocol
     +  extension, pre-multiplied alpha is used for pixel values.
     +/
    enum Format : uint
    {
        /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
        argb8888 = 0,
        /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
        xrgb8888 = 1,
        /// 8-bit color index format, [7:0] C
        c8 = 0x20203843,
        /// 8-bit RGB format, [7:0] R:G:B 3:3:2
        rgb332 = 0x38424752,
        /// 8-bit BGR format, [7:0] B:G:R 2:3:3
        bgr233 = 0x38524742,
        /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
        xrgb4444 = 0x32315258,
        /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
        xbgr4444 = 0x32314258,
        /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
        rgbx4444 = 0x32315852,
        /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
        bgrx4444 = 0x32315842,
        /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
        argb4444 = 0x32315241,
        /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
        abgr4444 = 0x32314241,
        /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
        rgba4444 = 0x32314152,
        /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
        bgra4444 = 0x32314142,
        /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
        xrgb1555 = 0x35315258,
        /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
        xbgr1555 = 0x35314258,
        /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
        rgbx5551 = 0x35315852,
        /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
        bgrx5551 = 0x35315842,
        /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
        argb1555 = 0x35315241,
        /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
        abgr1555 = 0x35314241,
        /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
        rgba5551 = 0x35314152,
        /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
        bgra5551 = 0x35314142,
        /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
        rgb565 = 0x36314752,
        /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
        bgr565 = 0x36314742,
        /// 24-bit RGB format, [23:0] R:G:B little endian
        rgb888 = 0x34324752,
        /// 24-bit BGR format, [23:0] B:G:R little endian
        bgr888 = 0x34324742,
        /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
        xbgr8888 = 0x34324258,
        /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
        rgbx8888 = 0x34325852,
        /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
        bgrx8888 = 0x34325842,
        /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
        abgr8888 = 0x34324241,
        /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
        rgba8888 = 0x34324152,
        /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
        bgra8888 = 0x34324142,
        /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
        xrgb2101010 = 0x30335258,
        /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
        xbgr2101010 = 0x30334258,
        /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
        rgbx1010102 = 0x30335852,
        /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
        bgrx1010102 = 0x30335842,
        /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
        argb2101010 = 0x30335241,
        /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
        abgr2101010 = 0x30334241,
        /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
        rgba1010102 = 0x30334152,
        /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
        bgra1010102 = 0x30334142,
        /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
        yuyv = 0x56595559,
        /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
        yvyu = 0x55595659,
        /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
        uyvy = 0x59565955,
        /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
        vyuy = 0x59555956,
        /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
        ayuv = 0x56555941,
        /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
        nv12 = 0x3231564e,
        /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
        nv21 = 0x3132564e,
        /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
        nv16 = 0x3631564e,
        /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
        nv61 = 0x3136564e,
        /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
        yuv410 = 0x39565559,
        /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
        yvu410 = 0x39555659,
        /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
        yuv411 = 0x31315559,
        /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
        yvu411 = 0x31315659,
        /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
        yuv420 = 0x32315559,
        /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
        yvu420 = 0x32315659,
        /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
        yuv422 = 0x36315559,
        /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
        yvu422 = 0x36315659,
        /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
        yuv444 = 0x34325559,
        /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
        yvu444 = 0x34325659,
        /// [7:0] R
        r8 = 0x20203852,
        /// [15:0] R little endian
        r16 = 0x20363152,
        /// [15:0] R:G 8:8 little endian
        rg88 = 0x38384752,
        /// [15:0] G:R 8:8 little endian
        gr88 = 0x38385247,
        /// [31:0] R:G 16:16 little endian
        rg1616 = 0x32334752,
        /// [31:0] G:R 16:16 little endian
        gr1616 = 0x32335247,
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        xrgb16161616f = 0x48345258,
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        xbgr16161616f = 0x48344258,
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        argb16161616f = 0x48345241,
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        abgr16161616f = 0x48344241,
        /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
        xyuv8888 = 0x56555958,
        /// [23:0] Cr:Cb:Y 8:8:8 little endian
        vuy888 = 0x34325556,
        /// Y followed by U then V, 10:10:10. Non-linear modifier only
        vuy101010 = 0x30335556,
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
        y210 = 0x30313259,
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
        y212 = 0x32313259,
        /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
        y216 = 0x36313259,
        /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
        y410 = 0x30313459,
        /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        y412 = 0x32313459,
        /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
        y416 = 0x36313459,
        /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
        xvyu2101010 = 0x30335658,
        /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        xvyu1216161616 = 0x36335658,
        /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
        xvyu16161616 = 0x38345658,
        /// [63:0] A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        y0l0 = 0x304c3059,
        /// [63:0] X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        x0l0 = 0x304c3058,
        /// [63:0] A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
        y0l2 = 0x324c3059,
        /// [63:0] X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
        x0l2 = 0x324c3058,
        yuv4208bit = 0x38305559,
        yuv42010bit = 0x30315559,
        xrgb8888A8 = 0x38415258,
        xbgr8888A8 = 0x38414258,
        rgbx8888A8 = 0x38415852,
        bgrx8888A8 = 0x38415842,
        rgb888A8 = 0x38413852,
        bgr888A8 = 0x38413842,
        rgb565A8 = 0x38413552,
        bgr565A8 = 0x38413542,
        /// non-subsampled Cr:Cb plane
        nv24 = 0x3432564e,
        /// non-subsampled Cb:Cr plane
        nv42 = 0x3234564e,
        /// 2x1 subsampled Cr:Cb plane, 10 bit per channel
        p210 = 0x30313250,
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel
        p010 = 0x30313050,
        /// 2x2 subsampled Cr:Cb plane 12 bits per channel
        p012 = 0x32313050,
        /// 2x2 subsampled Cr:Cb plane 16 bits per channel
        p016 = 0x36313050,
        /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
        axbxgxrx106106106106 = 0x30314241,
        /// 2x2 subsampled Cr:Cb plane
        nv15 = 0x3531564e,
        q410 = 0x30313451,
        q401 = 0x31303451,
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        xrgb16161616 = 0x38345258,
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        xbgr16161616 = 0x38344258,
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        argb16161616 = 0x38345241,
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        abgr16161616 = 0x38344241,
        /// [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
        c1 = 0x20203143,
        /// [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
        c2 = 0x20203243,
        /// [7:0] C0:C1 4:4 two pixels/byte
        c4 = 0x20203443,
        /// [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
        d1 = 0x20203144,
        /// [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
        d2 = 0x20203244,
        /// [7:0] D0:D1 4:4 two pixels/byte
        d4 = 0x20203444,
        /// [7:0] D
        d8 = 0x20203844,
        /// [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
        r1 = 0x20203152,
        /// [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
        r2 = 0x20203252,
        /// [7:0] R0:R1 4:4 two pixels/byte
        r4 = 0x20203452,
        /// [15:0] x:R 6:10 little endian
        r10 = 0x20303152,
        /// [15:0] x:R 4:12 little endian
        r12 = 0x20323152,
        /// [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
        avuy8888 = 0x59555641,
        /// [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
        xvuy8888 = 0x59555658,
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel packed
        p030 = 0x30333050,
    }

    /// Destroy this WlShm object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  create a shm pool
     +
     +  Create a new wl_shm_pool object.
     +
     +  The pool can be used to create shared memory based buffer
     +  objects.  The server will mmap size bytes of the passed file
     +  descriptor, to use as backing memory for the pool.
     +/
    WlShmPool createPool(int fd,
                         int size)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createPoolOpCode, WlShmPool.iface.native, null, fd, size
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlShmPool)_p;
        return new WlShmPool(_pp);
    }

    /++
     +  release the shm object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the shm object anymore.
     +
     +  Objects created via this interface remain unaffected.
     +/
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  pixel format description
     +
     +  Informs the client about a valid pixel format that
     +  can be used for buffers. Known formats include
     +  argb8888 and xrgb8888.
     +/
    @property void onFormat(OnFormatEventDg dg)
    {
        _onFormat = dg;
    }

    private OnFormatEventDg _onFormat;
}

/++
 +  content for a wl_surface
 +
 +  A buffer provides the content for a wl_surface. Buffers are
 +  created through factory interfaces such as wl_shm, wp_linux_buffer_params
 +  $(LPAREN)from the linux-dmabuf protocol extension$(RPAREN) or similar. It has a width and
 +  a height and can be attached to a wl_surface, but the mechanism by which a
 +  client provides and updates the contents is defined by the buffer factory
 +  interface.
 +
 +  Color channels are assumed to be electrical rather than optical $(LPAREN)in other
 +  words, encoded with a transfer function$(RPAREN) unless otherwise specified. If
 +  the buffer uses a format that has an alpha channel, the alpha channel is
 +  assumed to be premultiplied into the electrical color channel values
 +  $(LPAREN)after transfer function encoding$(RPAREN) unless otherwise specified.
 +
 +  Note, because wl_buffer objects are created from multiple independent
 +  factory interfaces, the wl_buffer interface is frozen at version 1.
 +/
final class WlBuffer : WlProxy
{
    /// Version of wayland.wl_buffer
    enum ver = 1;

    /// Build a WlBuffer from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_buffer_listener, cast(void*) this);
    }

    /// Interface object that creates WlBuffer objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlBufferIface;
    }

    /// Op-code of WlBuffer.destroy.
    enum destroyOpCode = 0;

    /// Version of wayland protocol introducing WlBuffer.destroy.
    enum destroySinceVersion = 1;

    /// wayland protocol version introducing WlBuffer.onRelease.
    enum onReleaseSinceVersion = 1;

    /// Event delegate signature of WlBuffer.onRelease.
    alias OnReleaseEventDg = void delegate(WlBuffer wlBuffer);

    /++
     +  destroy a buffer
     +
     +  Destroy a buffer. If and how you need to release the backing
     +  storage is defined by the buffer factory interface.
     +
     +  For possible side-effects to a surface, see wl_surface.attach.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  compositor releases buffer
     +
     +  Sent when this wl_buffer is no longer used by the compositor.
     +  The client is now free to reuse or destroy this buffer and its
     +  backing storage.
     +
     +  If a client receives a release event before the frame callback
     +  requested in the same wl_surface.commit that attaches this
     +  wl_buffer to a surface, then the client is immediately free to
     +  reuse the buffer and its backing storage, and does not need a
     +  second buffer for the next surface content update. Typically
     +  this is possible, when the compositor maintains a copy of the
     +  wl_surface contents, e.g. as a GL texture. This is an important
     +  optimization for GL$(LPAREN)ES$(RPAREN) compositors with wl_shm clients.
     +/
    @property void onRelease(OnReleaseEventDg dg)
    {
        _onRelease = dg;
    }

    private OnReleaseEventDg _onRelease;
}

/++
 +  offer to transfer data
 +
 +  A wl_data_offer represents a piece of data offered for transfer
 +  by another client $(LPAREN)the source client$(RPAREN).  It is used by the
 +  copy-and-paste and drag-and-drop mechanisms.  The offer
 +  describes the different mime types that the data can be
 +  converted to and provides the mechanism for transferring the
 +  data directly from the source client.
 +/
final class WlDataOffer : WlProxy
{
    /// Version of wayland.wl_data_offer
    enum ver = 3;

    /// Build a WlDataOffer from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_data_offer_listener, cast(void*) this);
    }

    /// Interface object that creates WlDataOffer objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlDataOfferIface;
    }

    /// Op-code of WlDataOffer.accept.
    enum acceptOpCode = 0;
    /// Op-code of WlDataOffer.receive.
    enum receiveOpCode = 1;
    /// Op-code of WlDataOffer.destroy.
    enum destroyOpCode = 2;
    /// Op-code of WlDataOffer.finish.
    enum finishOpCode = 3;
    /// Op-code of WlDataOffer.setActions.
    enum setActionsOpCode = 4;

    /// Version of wayland protocol introducing WlDataOffer.accept.
    enum acceptSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataOffer.receive.
    enum receiveSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataOffer.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlDataOffer.finish.
    enum finishSinceVersion = 3;
    /// Version of wayland protocol introducing WlDataOffer.setActions.
    enum setActionsSinceVersion = 3;

    /// wayland protocol version introducing WlDataOffer.onOffer.
    enum onOfferSinceVersion = 1;
    /// wayland protocol version introducing WlDataOffer.onSourceActions.
    enum onSourceActionsSinceVersion = 3;
    /// wayland protocol version introducing WlDataOffer.onAction.
    enum onActionSinceVersion = 3;

    /// Event delegate signature of WlDataOffer.onOffer.
    alias OnOfferEventDg = void delegate(WlDataOffer wlDataOffer,
                                         string mimeType);
    /// Event delegate signature of WlDataOffer.onSourceActions.
    alias OnSourceActionsEventDg = void delegate(WlDataOffer wlDataOffer,
                                                 WlDataDeviceManager.DndAction sourceActions);
    /// Event delegate signature of WlDataOffer.onAction.
    alias OnActionEventDg = void delegate(WlDataOffer wlDataOffer,
                                          WlDataDeviceManager.DndAction dndAction);

    enum Error : uint
    {
        /// finish request was called untimely
        invalidFinish = 0,
        /// action mask contains invalid values
        invalidActionMask = 1,
        /// action argument has an invalid value
        invalidAction = 2,
        /// offer doesn't accept this request
        invalidOffer = 3,
    }

    /++
     +  accept one of the offered mime types
     +
     +  Indicate that the client can accept the given mime type, or
     +  NULL for not accepted.
     +
     +  For objects of version 2 or older, this request is used by the
     +  client to give feedback whether the client can receive the given
     +  mime type, or NULL if none is accepted; the feedback does not
     +  determine whether the drag-and-drop operation succeeds or not.
     +
     +  For objects of version 3 or newer, this request determines the
     +  final result of the drag-and-drop operation. If the end result
     +  is that no mime types were accepted, the drag-and-drop operation
     +  will be cancelled and the corresponding drag source will receive
     +  wl_data_source.cancelled. Clients may still use this event in
     +  conjunction with wl_data_source.action for feedback.
     +/
    void accept(uint serial,
                string mimeType)
    {
        wl_proxy_marshal(
            proxy, acceptOpCode, serial, toStringz(mimeType)
        );
    }

    /++
     +  request that the data is transferred
     +
     +  To transfer the offered data, the client issues this request
     +  and indicates the mime type it wants to receive.  The transfer
     +  happens through the passed file descriptor $(LPAREN)typically created
     +  with the pipe system call$(RPAREN).  The source client writes the data
     +  in the mime type representation requested and then closes the
     +  file descriptor.
     +
     +  The receiving client reads from the read end of the pipe until
     +  EOF and then closes its end, at which point the transfer is
     +  complete.
     +
     +  This request may happen multiple times for different mime types,
     +  both before and after wl_data_device.drop. Drag-and-drop destination
     +  clients may preemptively fetch data or examine it more closely to
     +  determine acceptance.
     +/
    void receive(string mimeType,
                 int fd)
    {
        wl_proxy_marshal(
            proxy, receiveOpCode, toStringz(mimeType), fd
        );
    }

    /++
     +  destroy data offer
     +
     +  Destroy the data offer.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  the offer will no longer be used
     +
     +  Notifies the compositor that the drag destination successfully
     +  finished the drag-and-drop operation.
     +
     +  Upon receiving this request, the compositor will emit
     +  wl_data_source.dnd_finished on the drag source client.
     +
     +  It is a client error to perform other requests than
     +  wl_data_offer.destroy after this one. It is also an error to perform
     +  this request after a NULL mime type has been set in
     +  wl_data_offer.accept or no action was received through
     +  wl_data_offer.action.
     +
     +  If wl_data_offer.finish request is received for a non drag and drop
     +  operation, the invalid_finish protocol error is raised.
     +/
    void finish()
    {
        wl_proxy_marshal(
            proxy, finishOpCode
        );
    }

    /++
     +  set the available/preferred drag-and-drop actions
     +
     +  Sets the actions that the destination side client supports for
     +  this operation. This request may trigger the emission of
     +  wl_data_source.action and wl_data_offer.action events if the compositor
     +  needs to change the selected action.
     +
     +  This request can be called multiple times throughout the
     +  drag-and-drop operation, typically in response to wl_data_device.enter
     +  or wl_data_device.motion events.
     +
     +  This request determines the final result of the drag-and-drop
     +  operation. If the end result is that no action is accepted,
     +  the drag source will receive wl_data_source.cancelled.
     +
     +  The dnd_actions argument must contain only values expressed in the
     +  wl_data_device_manager.dnd_actions enum, and the preferred_action
     +  argument must only contain one of those values set, otherwise it
     +  will result in a protocol error.
     +
     +  While managing an "ask" action, the destination drag-and-drop client
     +  may perform further wl_data_offer.receive requests, and is expected
     +  to perform one last wl_data_offer.set_actions request with a preferred
     +  action other than "ask" $(LPAREN)and optionally wl_data_offer.accept$(RPAREN) before
     +  requesting wl_data_offer.finish, in order to convey the action selected
     +  by the user. If the preferred action is not in the
     +  wl_data_offer.source_actions mask, an error will be raised.
     +
     +  If the "ask" action is dismissed $(LPAREN)e.g. user cancellation$(RPAREN), the client
     +  is expected to perform wl_data_offer.destroy right away.
     +
     +  This request can only be made on drag-and-drop offers, a protocol error
     +  will be raised otherwise.
     +/
    void setActions(WlDataDeviceManager.DndAction dndActions,
                    WlDataDeviceManager.DndAction preferredAction)
    {
        wl_proxy_marshal(
            proxy, setActionsOpCode, dndActions, preferredAction
        );
    }

    /++
     +  advertise offered mime type
     +
     +  Sent immediately after creating the wl_data_offer object.  One
     +  event per offered mime type.
     +/
    @property void onOffer(OnOfferEventDg dg)
    {
        _onOffer = dg;
    }

    /++
     +  notify the source-side available actions
     +
     +  This event indicates the actions offered by the data source. It
     +  will be sent immediately after creating the wl_data_offer object,
     +  or anytime the source side changes its offered actions through
     +  wl_data_source.set_actions.
     +/
    @property void onSourceActions(OnSourceActionsEventDg dg)
    {
        _onSourceActions = dg;
    }

    /++
     +  notify the selected action
     +
     +  This event indicates the action selected by the compositor after
     +  matching the source/destination side actions. Only one action $(LPAREN)or
     +  none$(RPAREN) will be offered here.
     +
     +  This event can be emitted multiple times during the drag-and-drop
     +  operation in response to destination side action changes through
     +  wl_data_offer.set_actions.
     +
     +  This event will no longer be emitted after wl_data_device.drop
     +  happened on the drag-and-drop destination, the client must
     +  honor the last action received, or the last preferred one set
     +  through wl_data_offer.set_actions when handling an "ask" action.
     +
     +  Compositors may also change the selected action on the fly, mainly
     +  in response to keyboard modifier changes during the drag-and-drop
     +  operation.
     +
     +  The most recent action received is always the valid one. Prior to
     +  receiving wl_data_device.drop, the chosen action may change $(LPAREN)e.g.
     +  due to keyboard modifiers being pressed$(RPAREN). At the time of receiving
     +  wl_data_device.drop the drag-and-drop destination must honor the
     +  last action received.
     +
     +  Action changes may still happen after wl_data_device.drop,
     +  especially on "ask" actions, where the drag-and-drop destination
     +  may choose another action afterwards. Action changes happening
     +  at this stage are always the result of inter-client negotiation, the
     +  compositor shall no longer be able to induce a different action.
     +
     +  Upon "ask" actions, it is expected that the drag-and-drop destination
     +  may potentially choose a different action and/or mime type,
     +  based on wl_data_offer.source_actions and finally chosen by the
     +  user $(LPAREN)e.g. popping up a menu with the available options$(RPAREN). The
     +  final wl_data_offer.set_actions and wl_data_offer.accept requests
     +  must happen before the call to wl_data_offer.finish.
     +/
    @property void onAction(OnActionEventDg dg)
    {
        _onAction = dg;
    }

    private OnOfferEventDg _onOffer;
    private OnSourceActionsEventDg _onSourceActions;
    private OnActionEventDg _onAction;
}

/++
 +  offer to transfer data
 +
 +  The wl_data_source object is the source side of a wl_data_offer.
 +  It is created by the source client in a data transfer and
 +  provides a way to describe the offered data and a way to respond
 +  to requests to transfer the data.
 +/
final class WlDataSource : WlProxy
{
    /// Version of wayland.wl_data_source
    enum ver = 3;

    /// Build a WlDataSource from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_data_source_listener, cast(void*) this);
    }

    /// Interface object that creates WlDataSource objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlDataSourceIface;
    }

    /// Op-code of WlDataSource.offer.
    enum offerOpCode = 0;
    /// Op-code of WlDataSource.destroy.
    enum destroyOpCode = 1;
    /// Op-code of WlDataSource.setActions.
    enum setActionsOpCode = 2;

    /// Version of wayland protocol introducing WlDataSource.offer.
    enum offerSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataSource.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlDataSource.setActions.
    enum setActionsSinceVersion = 3;

    /// wayland protocol version introducing WlDataSource.onTarget.
    enum onTargetSinceVersion = 1;
    /// wayland protocol version introducing WlDataSource.onSend.
    enum onSendSinceVersion = 1;
    /// wayland protocol version introducing WlDataSource.onCancelled.
    enum onCancelledSinceVersion = 1;
    /// wayland protocol version introducing WlDataSource.onDndDropPerformed.
    enum onDndDropPerformedSinceVersion = 3;
    /// wayland protocol version introducing WlDataSource.onDndFinished.
    enum onDndFinishedSinceVersion = 3;
    /// wayland protocol version introducing WlDataSource.onAction.
    enum onActionSinceVersion = 3;

    /// Event delegate signature of WlDataSource.onTarget.
    alias OnTargetEventDg = void delegate(WlDataSource wlDataSource,
                                          string mimeType);
    /// Event delegate signature of WlDataSource.onSend.
    alias OnSendEventDg = void delegate(WlDataSource wlDataSource,
                                        string mimeType,
                                        int fd);
    /// Event delegate signature of WlDataSource.onCancelled.
    alias OnCancelledEventDg = void delegate(WlDataSource wlDataSource);
    /// Event delegate signature of WlDataSource.onDndDropPerformed.
    alias OnDndDropPerformedEventDg = void delegate(WlDataSource wlDataSource);
    /// Event delegate signature of WlDataSource.onDndFinished.
    alias OnDndFinishedEventDg = void delegate(WlDataSource wlDataSource);
    /// Event delegate signature of WlDataSource.onAction.
    alias OnActionEventDg = void delegate(WlDataSource wlDataSource,
                                          WlDataDeviceManager.DndAction dndAction);

    enum Error : uint
    {
        /// action mask contains invalid values
        invalidActionMask = 0,
        /// source doesn't accept this request
        invalidSource = 1,
    }

    /++
     +  add an offered mime type
     +
     +  This request adds a mime type to the set of mime types
     +  advertised to targets.  Can be called several times to offer
     +  multiple types.
     +/
    void offer(string mimeType)
    {
        wl_proxy_marshal(
            proxy, offerOpCode, toStringz(mimeType)
        );
    }

    /++
     +  destroy the data source
     +
     +  Destroy the data source.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the available drag-and-drop actions
     +
     +  Sets the actions that the source side client supports for this
     +  operation. This request may trigger wl_data_source.action and
     +  wl_data_offer.action events if the compositor needs to change the
     +  selected action.
     +
     +  The dnd_actions argument must contain only values expressed in the
     +  wl_data_device_manager.dnd_actions enum, otherwise it will result
     +  in a protocol error.
     +
     +  This request must be made once only, and can only be made on sources
     +  used in drag-and-drop, so it must be performed before
     +  wl_data_device.start_drag. Attempting to use the source other than
     +  for drag-and-drop will raise a protocol error.
     +/
    void setActions(WlDataDeviceManager.DndAction dndActions)
    {
        wl_proxy_marshal(
            proxy, setActionsOpCode, dndActions
        );
    }

    /++
     +  a target accepts an offered mime type
     +
     +  Sent when a target accepts pointer_focus or motion events.  If
     +  a target does not accept any of the offered types, type is NULL.
     +
     +  Used for feedback during drag-and-drop.
     +/
    @property void onTarget(OnTargetEventDg dg)
    {
        _onTarget = dg;
    }

    /++
     +  send the data
     +
     +  Request for data from the client.  Send the data as the
     +  specified mime type over the passed file descriptor, then
     +  close it.
     +/
    @property void onSend(OnSendEventDg dg)
    {
        _onSend = dg;
    }

    /++
     +  selection was cancelled
     +
     +  This data source is no longer valid. There are several reasons why
     +  this could happen:
     +
     +  - The data source has been replaced by another data source.
     +  - The drag-and-drop operation was performed, but the drop destination
     +    did not accept any of the mime types offered through
     +    wl_data_source.target.
     +  - The drag-and-drop operation was performed, but the drop destination
     +    did not select any of the actions present in the mask offered through
     +    wl_data_source.action.
     +  - The drag-and-drop operation was performed but didn't happen over a
     +    surface.
     +  - The compositor cancelled the drag-and-drop operation $(LPAREN)e.g. compositor
     +    dependent timeouts to avoid stale drag-and-drop transfers$(RPAREN).
     +
     +  The client should clean up and destroy this data source.
     +
     +  For objects of version 2 or older, wl_data_source.cancelled will
     +  only be emitted if the data source was replaced by another data
     +  source.
     +/
    @property void onCancelled(OnCancelledEventDg dg)
    {
        _onCancelled = dg;
    }

    /++
     +  the drag-and-drop operation physically finished
     +
     +  The user performed the drop action. This event does not indicate
     +  acceptance, wl_data_source.cancelled may still be emitted afterwards
     +  if the drop destination does not accept any mime type.
     +
     +  However, this event might however not be received if the compositor
     +  cancelled the drag-and-drop operation before this event could happen.
     +
     +  Note that the data_source may still be used in the future and should
     +  not be destroyed here.
     +/
    @property void onDndDropPerformed(OnDndDropPerformedEventDg dg)
    {
        _onDndDropPerformed = dg;
    }

    /++
     +  the drag-and-drop operation concluded
     +
     +  The drop destination finished interoperating with this data
     +  source, so the client is now free to destroy this data source and
     +  free all associated data.
     +
     +  If the action used to perform the operation was "move", the
     +  source can now delete the transferred data.
     +/
    @property void onDndFinished(OnDndFinishedEventDg dg)
    {
        _onDndFinished = dg;
    }

    /++
     +  notify the selected action
     +
     +  This event indicates the action selected by the compositor after
     +  matching the source/destination side actions. Only one action $(LPAREN)or
     +  none$(RPAREN) will be offered here.
     +
     +  This event can be emitted multiple times during the drag-and-drop
     +  operation, mainly in response to destination side changes through
     +  wl_data_offer.set_actions, and as the data device enters/leaves
     +  surfaces.
     +
     +  It is only possible to receive this event after
     +  wl_data_source.dnd_drop_performed if the drag-and-drop operation
     +  ended in an "ask" action, in which case the final wl_data_source.action
     +  event will happen immediately before wl_data_source.dnd_finished.
     +
     +  Compositors may also change the selected action on the fly, mainly
     +  in response to keyboard modifier changes during the drag-and-drop
     +  operation.
     +
     +  The most recent action received is always the valid one. The chosen
     +  action may change alongside negotiation $(LPAREN)e.g. an "ask" action can turn
     +  into a "move" operation$(RPAREN), so the effects of the final action must
     +  always be applied in wl_data_offer.dnd_finished.
     +
     +  Clients can trigger cursor surface changes from this point, so
     +  they reflect the current action.
     +/
    @property void onAction(OnActionEventDg dg)
    {
        _onAction = dg;
    }

    private OnTargetEventDg _onTarget;
    private OnSendEventDg _onSend;
    private OnCancelledEventDg _onCancelled;
    private OnDndDropPerformedEventDg _onDndDropPerformed;
    private OnDndFinishedEventDg _onDndFinished;
    private OnActionEventDg _onAction;
}

/++
 +  data transfer device
 +
 +  There is one wl_data_device per seat which can be obtained
 +  from the global wl_data_device_manager singleton.
 +
 +  A wl_data_device provides access to inter-client data transfer
 +  mechanisms such as copy-and-paste and drag-and-drop.
 +/
final class WlDataDevice : WlProxy
{
    /// Version of wayland.wl_data_device
    enum ver = 3;

    /// Build a WlDataDevice from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_data_device_listener, cast(void*) this);
    }

    /// Interface object that creates WlDataDevice objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlDataDeviceIface;
    }

    /// Op-code of WlDataDevice.startDrag.
    enum startDragOpCode = 0;
    /// Op-code of WlDataDevice.setSelection.
    enum setSelectionOpCode = 1;
    /// Op-code of WlDataDevice.release.
    enum releaseOpCode = 2;

    /// Version of wayland protocol introducing WlDataDevice.startDrag.
    enum startDragSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataDevice.setSelection.
    enum setSelectionSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataDevice.release.
    enum releaseSinceVersion = 2;

    /// wayland protocol version introducing WlDataDevice.onDataOffer.
    enum onDataOfferSinceVersion = 1;
    /// wayland protocol version introducing WlDataDevice.onEnter.
    enum onEnterSinceVersion = 1;
    /// wayland protocol version introducing WlDataDevice.onLeave.
    enum onLeaveSinceVersion = 1;
    /// wayland protocol version introducing WlDataDevice.onMotion.
    enum onMotionSinceVersion = 1;
    /// wayland protocol version introducing WlDataDevice.onDrop.
    enum onDropSinceVersion = 1;
    /// wayland protocol version introducing WlDataDevice.onSelection.
    enum onSelectionSinceVersion = 1;

    /// Event delegate signature of WlDataDevice.onDataOffer.
    alias OnDataOfferEventDg = void delegate(WlDataDevice wlDataDevice,
                                             WlDataOffer id);
    /// Event delegate signature of WlDataDevice.onEnter.
    alias OnEnterEventDg = void delegate(WlDataDevice wlDataDevice,
                                         uint serial,
                                         WlSurface surface,
                                         WlFixed x,
                                         WlFixed y,
                                         WlDataOffer id);
    /// Event delegate signature of WlDataDevice.onLeave.
    alias OnLeaveEventDg = void delegate(WlDataDevice wlDataDevice);
    /// Event delegate signature of WlDataDevice.onMotion.
    alias OnMotionEventDg = void delegate(WlDataDevice wlDataDevice,
                                          uint time,
                                          WlFixed x,
                                          WlFixed y);
    /// Event delegate signature of WlDataDevice.onDrop.
    alias OnDropEventDg = void delegate(WlDataDevice wlDataDevice);
    /// Event delegate signature of WlDataDevice.onSelection.
    alias OnSelectionEventDg = void delegate(WlDataDevice wlDataDevice,
                                             WlDataOffer id);

    enum Error : uint
    {
        /// given wl_surface has another role
        role = 0,
        /// source has already been used
        usedSource = 1,
    }

    /// Destroy this WlDataDevice object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  start drag-and-drop operation
     +
     +  This request asks the compositor to start a drag-and-drop
     +  operation on behalf of the client.
     +
     +  The source argument is the data source that provides the data
     +  for the eventual data transfer. If source is NULL, enter, leave
     +  and motion events are sent only to the client that initiated the
     +  drag and the client is expected to handle the data passing
     +  internally. If source is destroyed, the drag-and-drop session will be
     +  cancelled.
     +
     +  The origin surface is the surface where the drag originates and
     +  the client must have an active implicit grab that matches the
     +  serial.
     +
     +  The icon surface is an optional $(LPAREN)can be NULL$(RPAREN) surface that
     +  provides an icon to be moved around with the cursor.  Initially,
     +  the top-left corner of the icon surface is placed at the cursor
     +  hotspot, but subsequent wl_surface.offset requests can move the
     +  relative position. Attach requests must be confirmed with
     +  wl_surface.commit as usual. The icon surface is given the role of
     +  a drag-and-drop icon. If the icon surface already has another role,
     +  it raises a protocol error.
     +
     +  The input region is ignored for wl_surfaces with the role of a
     +  drag-and-drop icon.
     +
     +  The given source may not be used in any further set_selection or
     +  start_drag requests. Attempting to reuse a previously-used source
     +  may send a used_source error.
     +/
    void startDrag(WlDataSource source,
                   WlSurface origin,
                   WlSurface icon,
                   uint serial)
    {
        wl_proxy_marshal(
            proxy, startDragOpCode, source.proxy, origin.proxy, icon.proxy,
            serial
        );
    }

    /++
     +  copy data to the selection
     +
     +  This request asks the compositor to set the selection
     +  to the data from the source on behalf of the client.
     +
     +  To unset the selection, set the source to NULL.
     +
     +  The given source may not be used in any further set_selection or
     +  start_drag requests. Attempting to reuse a previously-used source
     +  may send a used_source error.
     +/
    void setSelection(WlDataSource source,
                      uint serial)
    {
        wl_proxy_marshal(
            proxy, setSelectionOpCode, source.proxy, serial
        );
    }

    /++
     +  destroy data device
     +
     +  This request destroys the data device.
     +/
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  introduce a new wl_data_offer
     +
     +  The data_offer event introduces a new wl_data_offer object,
     +  which will subsequently be used in either the
     +  data_device.enter event $(LPAREN)for drag-and-drop$(RPAREN) or the
     +  data_device.selection event $(LPAREN)for selections$(RPAREN).  Immediately
     +  following the data_device.data_offer event, the new data_offer
     +  object will send out data_offer.offer events to describe the
     +  mime types it offers.
     +/
    @property void onDataOffer(OnDataOfferEventDg dg)
    {
        _onDataOffer = dg;
    }

    /++
     +  initiate drag-and-drop session
     +
     +  This event is sent when an active drag-and-drop pointer enters
     +  a surface owned by the client.  The position of the pointer at
     +  enter time is provided by the x and y arguments, in surface-local
     +  coordinates.
     +/
    @property void onEnter(OnEnterEventDg dg)
    {
        _onEnter = dg;
    }

    /++
     +  end drag-and-drop session
     +
     +  This event is sent when the drag-and-drop pointer leaves the
     +  surface and the session ends.  The client must destroy the
     +  wl_data_offer introduced at enter time at this point.
     +/
    @property void onLeave(OnLeaveEventDg dg)
    {
        _onLeave = dg;
    }

    /++
     +  drag-and-drop session motion
     +
     +  This event is sent when the drag-and-drop pointer moves within
     +  the currently focused surface. The new position of the pointer
     +  is provided by the x and y arguments, in surface-local
     +  coordinates.
     +/
    @property void onMotion(OnMotionEventDg dg)
    {
        _onMotion = dg;
    }

    /++
     +  end drag-and-drop session successfully
     +
     +  The event is sent when a drag-and-drop operation is ended
     +  because the implicit grab is removed.
     +
     +  The drag-and-drop destination is expected to honor the last action
     +  received through wl_data_offer.action, if the resulting action is
     +  "copy" or "move", the destination can still perform
     +  wl_data_offer.receive requests, and is expected to end all
     +  transfers with a wl_data_offer.finish request.
     +
     +  If the resulting action is "ask", the action will not be considered
     +  final. The drag-and-drop destination is expected to perform one last
     +  wl_data_offer.set_actions request, or wl_data_offer.destroy in order
     +  to cancel the operation.
     +/
    @property void onDrop(OnDropEventDg dg)
    {
        _onDrop = dg;
    }

    /++
     +  advertise new selection
     +
     +  The selection event is sent out to notify the client of a new
     +  wl_data_offer for the selection for this device.  The
     +  data_device.data_offer and the data_offer.offer events are
     +  sent out immediately before this event to introduce the data
     +  offer object.  The selection event is sent to a client
     +  immediately before receiving keyboard focus and when a new
     +  selection is set while the client has keyboard focus.  The
     +  data_offer is valid until a new data_offer or NULL is received
     +  or until the client loses keyboard focus.  Switching surface with
     +  keyboard focus within the same client doesn't mean a new selection
     +  will be sent.  The client must destroy the previous selection
     +  data_offer, if any, upon receiving this event.
     +/
    @property void onSelection(OnSelectionEventDg dg)
    {
        _onSelection = dg;
    }

    private OnDataOfferEventDg _onDataOffer;
    private OnEnterEventDg _onEnter;
    private OnLeaveEventDg _onLeave;
    private OnMotionEventDg _onMotion;
    private OnDropEventDg _onDrop;
    private OnSelectionEventDg _onSelection;
}

/++
 +  data transfer interface
 +
 +  The wl_data_device_manager is a singleton global object that
 +  provides access to inter-client data transfer mechanisms such as
 +  copy-and-paste and drag-and-drop.  These mechanisms are tied to
 +  a wl_seat and this interface lets a client get a wl_data_device
 +  corresponding to a wl_seat.
 +
 +  Depending on the version bound, the objects created from the bound
 +  wl_data_device_manager object will have different requirements for
 +  functioning properly. See wl_data_source.set_actions,
 +  wl_data_offer.accept and wl_data_offer.finish for details.
 +/
final class WlDataDeviceManager : WlProxy
{
    /// Version of wayland.wl_data_device_manager
    enum ver = 3;

    /// Build a WlDataDeviceManager from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlDataDeviceManager objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlDataDeviceManagerIface;
    }

    /// Op-code of WlDataDeviceManager.createDataSource.
    enum createDataSourceOpCode = 0;
    /// Op-code of WlDataDeviceManager.getDataDevice.
    enum getDataDeviceOpCode = 1;

    /// Version of wayland protocol introducing WlDataDeviceManager.createDataSource.
    enum createDataSourceSinceVersion = 1;
    /// Version of wayland protocol introducing WlDataDeviceManager.getDataDevice.
    enum getDataDeviceSinceVersion = 1;

    /++
     +  drag and drop actions
     +
     +  This is a bitmask of the available/preferred actions in a
     +  drag-and-drop operation.
     +
     +  In the compositor, the selected action is a result of matching the
     +  actions offered by the source and destination sides.  "action" events
     +  with a "none" action will be sent to both source and destination if
     +  there is no match. All further checks will effectively happen on
     +  $(LPAREN)source actions ∩ destination actions$(RPAREN).
     +
     +  In addition, compositors may also pick different actions in
     +  reaction to key modifiers being pressed. One common design that
     +  is used in major toolkits $(LPAREN)and the behavior recommended for
     +  compositors$(RPAREN) is:
     +
     +  - If no modifiers are pressed, the first match $(LPAREN)in bit order$(RPAREN)
     +    will be used.
     +  - Pressing Shift selects "move", if enabled in the mask.
     +  - Pressing Control selects "copy", if enabled in the mask.
     +
     +  Behavior beyond that is considered implementation-dependent.
     +  Compositors may for example bind other modifiers $(LPAREN)like Alt/Meta$(RPAREN)
     +  or drags initiated with other buttons than BTN_LEFT to specific
     +  actions $(LPAREN)e.g. "ask"$(RPAREN).
     +/
    enum DndAction : uint
    {
        /// no action
        none = 0,
        /// copy action
        copy = 1,
        /// move action
        move = 2,
        /// ask action
        ask = 4,
    }

    /// Destroy this WlDataDeviceManager object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  create a new data source
     +
     +  Create a new data source.
     +/
    WlDataSource createDataSource()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, createDataSourceOpCode, WlDataSource.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlDataSource)_p;
        return new WlDataSource(_pp);
    }

    /++
     +  create a new data device
     +
     +  Create a new data device for a given seat.
     +/
    WlDataDevice getDataDevice(WlSeat seat)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getDataDeviceOpCode, WlDataDevice.iface.native, null,
            seat.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlDataDevice)_p;
        return new WlDataDevice(_pp);
    }
}

/++
 +  create desktop-style surfaces
 +
 +  This interface is implemented by servers that provide
 +  desktop-style user interfaces.
 +
 +  It allows clients to associate a wl_shell_surface with
 +  a basic surface.
 +
 +  Note! This protocol is deprecated and not intended for production use.
 +  For desktop-style user interfaces, use xdg_shell. Compositors and clients
 +  should not implement this interface.
 +/
final class WlShell : WlProxy
{
    /// Version of wayland.wl_shell
    enum ver = 1;

    /// Build a WlShell from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlShell objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlShellIface;
    }

    /// Op-code of WlShell.getShellSurface.
    enum getShellSurfaceOpCode = 0;

    /// Version of wayland protocol introducing WlShell.getShellSurface.
    enum getShellSurfaceSinceVersion = 1;

    enum Error : uint
    {
        /// given wl_surface has another role
        role = 0,
    }

    /// Destroy this WlShell object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  create a shell surface from a surface
     +
     +  Create a shell surface for an existing surface. This gives
     +  the wl_surface the role of a shell surface. If the wl_surface
     +  already has another role, it raises a protocol error.
     +
     +  Only one shell surface can be associated with a given surface.
     +/
    WlShellSurface getShellSurface(WlSurface surface)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getShellSurfaceOpCode, WlShellSurface.iface.native, null,
            surface.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlShellSurface)_p;
        return new WlShellSurface(_pp);
    }
}

/++
 +  desktop-style metadata interface
 +
 +  An interface that may be implemented by a wl_surface, for
 +  implementations that provide a desktop-style user interface.
 +
 +  It provides requests to treat surfaces like toplevel, fullscreen
 +  or popup windows, move, resize or maximize them, associate
 +  metadata like title and class, etc.
 +
 +  On the server side the object is automatically destroyed when
 +  the related wl_surface is destroyed. On the client side,
 +  wl_shell_surface_destroy$(LPAREN)$(RPAREN) must be called before destroying
 +  the wl_surface object.
 +/
final class WlShellSurface : WlProxy
{
    /// Version of wayland.wl_shell_surface
    enum ver = 1;

    /// Build a WlShellSurface from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_shell_surface_listener, cast(void*) this);
    }

    /// Interface object that creates WlShellSurface objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlShellSurfaceIface;
    }

    /// Op-code of WlShellSurface.pong.
    enum pongOpCode = 0;
    /// Op-code of WlShellSurface.move.
    enum moveOpCode = 1;
    /// Op-code of WlShellSurface.resize.
    enum resizeOpCode = 2;
    /// Op-code of WlShellSurface.setToplevel.
    enum setToplevelOpCode = 3;
    /// Op-code of WlShellSurface.setTransient.
    enum setTransientOpCode = 4;
    /// Op-code of WlShellSurface.setFullscreen.
    enum setFullscreenOpCode = 5;
    /// Op-code of WlShellSurface.setPopup.
    enum setPopupOpCode = 6;
    /// Op-code of WlShellSurface.setMaximized.
    enum setMaximizedOpCode = 7;
    /// Op-code of WlShellSurface.setTitle.
    enum setTitleOpCode = 8;
    /// Op-code of WlShellSurface.setClass.
    enum setClassOpCode = 9;

    /// Version of wayland protocol introducing WlShellSurface.pong.
    enum pongSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.move.
    enum moveSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.resize.
    enum resizeSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setToplevel.
    enum setToplevelSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setTransient.
    enum setTransientSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setFullscreen.
    enum setFullscreenSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setPopup.
    enum setPopupSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setMaximized.
    enum setMaximizedSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setTitle.
    enum setTitleSinceVersion = 1;
    /// Version of wayland protocol introducing WlShellSurface.setClass.
    enum setClassSinceVersion = 1;

    /// wayland protocol version introducing WlShellSurface.onPing.
    enum onPingSinceVersion = 1;
    /// wayland protocol version introducing WlShellSurface.onConfigure.
    enum onConfigureSinceVersion = 1;
    /// wayland protocol version introducing WlShellSurface.onPopupDone.
    enum onPopupDoneSinceVersion = 1;

    /// Event delegate signature of WlShellSurface.onPing.
    alias OnPingEventDg = void delegate(WlShellSurface wlShellSurface,
                                        uint serial);
    /// Event delegate signature of WlShellSurface.onConfigure.
    alias OnConfigureEventDg = void delegate(WlShellSurface wlShellSurface,
                                             Resize edges,
                                             int width,
                                             int height);
    /// Event delegate signature of WlShellSurface.onPopupDone.
    alias OnPopupDoneEventDg = void delegate(WlShellSurface wlShellSurface);

    /++
     +  edge values for resizing
     +
     +  These values are used to indicate which edge of a surface
     +  is being dragged in a resize operation. The server may
     +  use this information to adapt its behavior, e.g. choose
     +  an appropriate cursor image.
     +/
    enum Resize : uint
    {
        /// no edge
        none = 0,
        /// top edge
        top = 1,
        /// bottom edge
        bottom = 2,
        /// left edge
        left = 4,
        /// top and left edges
        topLeft = 5,
        /// bottom and left edges
        bottomLeft = 6,
        /// right edge
        right = 8,
        /// top and right edges
        topRight = 9,
        /// bottom and right edges
        bottomRight = 10,
    }

    /++
     +  details of transient behaviour
     +
     +  These flags specify details of the expected behaviour
     +  of transient surfaces. Used in the set_transient request.
     +/
    enum Transient : uint
    {
        /// do not set keyboard focus
        inactive = 0x1,
    }

    /++
     +  different method to set the surface fullscreen
     +
     +  Hints to indicate to the compositor how to deal with a conflict
     +  between the dimensions of the surface and the dimensions of the
     +  output. The compositor is free to ignore this parameter.
     +/
    enum FullscreenMethod : uint
    {
        /// no preference, apply default policy
        default_ = 0,
        /// scale, preserve the surface's aspect ratio and center on output
        scale = 1,
        /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
        driver = 2,
        /// no upscaling, center on output and add black borders to compensate size mismatch
        fill = 3,
    }

    /// Destroy this WlShellSurface object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  respond to a ping event
     +
     +  A client must respond to a ping event with a pong request or
     +  the client may be deemed unresponsive.
     +/
    void pong(uint serial)
    {
        wl_proxy_marshal(
            proxy, pongOpCode, serial
        );
    }

    /++
     +  start an interactive move
     +
     +  Start a pointer-driven move of the surface.
     +
     +  This request must be used in response to a button press event.
     +  The server may ignore move requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN).
     +/
    void move(WlSeat seat,
              uint serial)
    {
        wl_proxy_marshal(
            proxy, moveOpCode, seat.proxy, serial
        );
    }

    /++
     +  start an interactive resize
     +
     +  Start a pointer-driven resizing of the surface.
     +
     +  This request must be used in response to a button press event.
     +  The server may ignore resize requests depending on the state of
     +  the surface $(LPAREN)e.g. fullscreen or maximized$(RPAREN).
     +/
    void resize(WlSeat seat,
                uint serial,
                Resize edges)
    {
        wl_proxy_marshal(
            proxy, resizeOpCode, seat.proxy, serial, edges
        );
    }

    /++
     +  make the surface a toplevel surface
     +
     +  Map the surface as a toplevel surface.
     +
     +  A toplevel surface is not fullscreen, maximized or transient.
     +/
    void setToplevel()
    {
        wl_proxy_marshal(
            proxy, setToplevelOpCode
        );
    }

    /++
     +  make the surface a transient surface
     +
     +  Map the surface relative to an existing surface.
     +
     +  The x and y arguments specify the location of the upper left
     +  corner of the surface relative to the upper left corner of the
     +  parent surface, in surface-local coordinates.
     +
     +  The flags argument controls details of the transient behaviour.
     +/
    void setTransient(WlSurface parent,
                      int x,
                      int y,
                      Transient flags)
    {
        wl_proxy_marshal(
            proxy, setTransientOpCode, parent.proxy, x, y, flags
        );
    }

    /++
     +  make the surface a fullscreen surface
     +
     +  Map the surface as a fullscreen surface.
     +
     +  If an output parameter is given then the surface will be made
     +  fullscreen on that output. If the client does not specify the
     +  output then the compositor will apply its policy - usually
     +  choosing the output on which the surface has the biggest surface
     +  area.
     +
     +  The client may specify a method to resolve a size conflict
     +  between the output size and the surface size - this is provided
     +  through the method parameter.
     +
     +  The framerate parameter is used only when the method is set
     +  to "driver", to indicate the preferred framerate. A value of 0
     +  indicates that the client does not care about framerate.  The
     +  framerate is specified in mHz, that is framerate of 60000 is 60Hz.
     +
     +  A method of "scale" or "driver" implies a scaling operation of
     +  the surface, either via a direct scaling operation or a change of
     +  the output mode. This will override any kind of output scaling, so
     +  that mapping a surface with a buffer size equal to the mode can
     +  fill the screen independent of buffer_scale.
     +
     +  A method of "fill" means we don't scale up the buffer, however
     +  any output scale is applied. This means that you may run into
     +  an edge case where the application maps a buffer with the same
     +  size of the output mode but buffer_scale 1 $(LPAREN)thus making a
     +  surface larger than the output$(RPAREN). In this case it is allowed to
     +  downscale the results to fit the screen.
     +
     +  The compositor must reply to this request with a configure event
     +  with the dimensions for the output on which the surface will
     +  be made fullscreen.
     +/
    void setFullscreen(FullscreenMethod method,
                       uint framerate,
                       WlOutput output)
    {
        wl_proxy_marshal(
            proxy, setFullscreenOpCode, method, framerate, output.proxy
        );
    }

    /++
     +  make the surface a popup surface
     +
     +  Map the surface as a popup.
     +
     +  A popup surface is a transient surface with an added pointer
     +  grab.
     +
     +  An existing implicit grab will be changed to owner-events mode,
     +  and the popup grab will continue after the implicit grab ends
     +  $(LPAREN)i.e. releasing the mouse button does not cause the popup to
     +  be unmapped$(RPAREN).
     +
     +  The popup grab continues until the window is destroyed or a
     +  mouse button is pressed in any other client's window. A click
     +  in any of the client's surfaces is reported as normal, however,
     +  clicks in other clients' surfaces will be discarded and trigger
     +  the callback.
     +
     +  The x and y arguments specify the location of the upper left
     +  corner of the surface relative to the upper left corner of the
     +  parent surface, in surface-local coordinates.
     +/
    void setPopup(WlSeat seat,
                  uint serial,
                  WlSurface parent,
                  int x,
                  int y,
                  Transient flags)
    {
        wl_proxy_marshal(
            proxy, setPopupOpCode, seat.proxy, serial, parent.proxy, x, y, flags
        );
    }

    /++
     +  make the surface a maximized surface
     +
     +  Map the surface as a maximized surface.
     +
     +  If an output parameter is given then the surface will be
     +  maximized on that output. If the client does not specify the
     +  output then the compositor will apply its policy - usually
     +  choosing the output on which the surface has the biggest surface
     +  area.
     +
     +  The compositor will reply with a configure event telling
     +  the expected new surface size. The operation is completed
     +  on the next buffer attach to this surface.
     +
     +  A maximized surface typically fills the entire output it is
     +  bound to, except for desktop elements such as panels. This is
     +  the main difference between a maximized shell surface and a
     +  fullscreen shell surface.
     +
     +  The details depend on the compositor implementation.
     +/
    void setMaximized(WlOutput output)
    {
        wl_proxy_marshal(
            proxy, setMaximizedOpCode, output.proxy
        );
    }

    /++
     +  set surface title
     +
     +  Set a short title for the surface.
     +
     +  This string may be used to identify the surface in a task bar,
     +  window list, or other user interface elements provided by the
     +  compositor.
     +
     +  The string must be encoded in UTF-8.
     +/
    void setTitle(string title)
    {
        wl_proxy_marshal(
            proxy, setTitleOpCode, toStringz(title)
        );
    }

    /++
     +  set surface class
     +
     +  Set a class for the surface.
     +
     +  The surface class identifies the general class of applications
     +  to which the surface belongs. A common convention is to use the
     +  file name $(LPAREN)or the full path if it is a non-standard location$(RPAREN) of
     +  the application's .desktop file as the class.
     +/
    void setClass(string class_)
    {
        wl_proxy_marshal(
            proxy, setClassOpCode, toStringz(class_)
        );
    }

    /++
     +  ping client
     +
     +  Ping a client to check if it is receiving events and sending
     +  requests. A client is expected to reply with a pong request.
     +/
    @property void onPing(OnPingEventDg dg)
    {
        _onPing = dg;
    }

    /++
     +  suggest resize
     +
     +  The configure event asks the client to resize its surface.
     +
     +  The size is a hint, in the sense that the client is free to
     +  ignore it if it doesn't resize, pick a smaller size $(LPAREN)to
     +  satisfy aspect ratio or resize in steps of NxM pixels$(RPAREN).
     +
     +  The edges parameter provides a hint about how the surface
     +  was resized. The client may use this information to decide
     +  how to adjust its content to the new size $(LPAREN)e.g. a scrolling
     +  area might adjust its content position to leave the viewable
     +  content unmoved$(RPAREN).
     +
     +  The client is free to dismiss all but the last configure
     +  event it received.
     +
     +  The width and height arguments specify the size of the window
     +  in surface-local coordinates.
     +/
    @property void onConfigure(OnConfigureEventDg dg)
    {
        _onConfigure = dg;
    }

    /++
     +  popup interaction is done
     +
     +  The popup_done event is sent out when a popup grab is broken,
     +  that is, when the user clicks a surface that doesn't belong
     +  to the client owning the popup surface.
     +/
    @property void onPopupDone(OnPopupDoneEventDg dg)
    {
        _onPopupDone = dg;
    }

    private OnPingEventDg _onPing;
    private OnConfigureEventDg _onConfigure;
    private OnPopupDoneEventDg _onPopupDone;
}

/++
 +  an onscreen surface
 +
 +  A surface is a rectangular area that may be displayed on zero
 +  or more outputs, and shown any number of times at the compositor's
 +  discretion. They can present wl_buffers, receive user input, and
 +  define a local coordinate system.
 +
 +  The size of a surface $(LPAREN)and relative positions on it$(RPAREN) is described
 +  in surface-local coordinates, which may differ from the buffer
 +  coordinates of the pixel content, in case a buffer_transform
 +  or a buffer_scale is used.
 +
 +  A surface without a "role" is fairly useless: a compositor does
 +  not know where, when or how to present it. The role is the
 +  purpose of a wl_surface. Examples of roles are a cursor for a
 +  pointer $(LPAREN)as set by wl_pointer.set_cursor$(RPAREN), a drag icon
 +  $(LPAREN)wl_data_device.start_drag$(RPAREN), a sub-surface
 +  $(LPAREN)wl_subcompositor.get_subsurface$(RPAREN), and a window as defined by a
 +  shell protocol $(LPAREN)e.g. wl_shell.get_shell_surface$(RPAREN).
 +
 +  A surface can have only one role at a time. Initially a
 +  wl_surface does not have a role. Once a wl_surface is given a
 +  role, it is set permanently for the whole lifetime of the
 +  wl_surface object. Giving the current role again is allowed,
 +  unless explicitly forbidden by the relevant interface
 +  specification.
 +
 +  Surface roles are given by requests in other interfaces such as
 +  wl_pointer.set_cursor. The request should explicitly mention
 +  that this request gives a role to a wl_surface. Often, this
 +  request also creates a new protocol object that represents the
 +  role and adds additional functionality to wl_surface. When a
 +  client wants to destroy a wl_surface, they must destroy this role
 +  object before the wl_surface, otherwise a defunct_role_object error is
 +  sent.
 +
 +  Destroying the role object does not remove the role from the
 +  wl_surface, but it may stop the wl_surface from "playing the role".
 +  For instance, if a wl_subsurface object is destroyed, the wl_surface
 +  it was created for will be unmapped and forget its position and
 +  z-order. It is allowed to create a wl_subsurface for the same
 +  wl_surface again, but it is not allowed to use the wl_surface as
 +  a cursor $(LPAREN)cursor is a different role than sub-surface, and role
 +  switching is not allowed$(RPAREN).
 +/
final class WlSurface : WlProxy
{
    /// Version of wayland.wl_surface
    enum ver = 6;

    /// Build a WlSurface from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_surface_listener, cast(void*) this);
    }

    /// Interface object that creates WlSurface objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlSurfaceIface;
    }

    /// Op-code of WlSurface.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WlSurface.attach.
    enum attachOpCode = 1;
    /// Op-code of WlSurface.damage.
    enum damageOpCode = 2;
    /// Op-code of WlSurface.frame.
    enum frameOpCode = 3;
    /// Op-code of WlSurface.setOpaqueRegion.
    enum setOpaqueRegionOpCode = 4;
    /// Op-code of WlSurface.setInputRegion.
    enum setInputRegionOpCode = 5;
    /// Op-code of WlSurface.commit.
    enum commitOpCode = 6;
    /// Op-code of WlSurface.setBufferTransform.
    enum setBufferTransformOpCode = 7;
    /// Op-code of WlSurface.setBufferScale.
    enum setBufferScaleOpCode = 8;
    /// Op-code of WlSurface.damageBuffer.
    enum damageBufferOpCode = 9;
    /// Op-code of WlSurface.offset.
    enum offsetOpCode = 10;

    /// Version of wayland protocol introducing WlSurface.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.attach.
    enum attachSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.damage.
    enum damageSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.frame.
    enum frameSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.setOpaqueRegion.
    enum setOpaqueRegionSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.setInputRegion.
    enum setInputRegionSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.commit.
    enum commitSinceVersion = 1;
    /// Version of wayland protocol introducing WlSurface.setBufferTransform.
    enum setBufferTransformSinceVersion = 2;
    /// Version of wayland protocol introducing WlSurface.setBufferScale.
    enum setBufferScaleSinceVersion = 3;
    /// Version of wayland protocol introducing WlSurface.damageBuffer.
    enum damageBufferSinceVersion = 4;
    /// Version of wayland protocol introducing WlSurface.offset.
    enum offsetSinceVersion = 5;

    /// wayland protocol version introducing WlSurface.onEnter.
    enum onEnterSinceVersion = 1;
    /// wayland protocol version introducing WlSurface.onLeave.
    enum onLeaveSinceVersion = 1;
    /// wayland protocol version introducing WlSurface.onPreferredBufferScale.
    enum onPreferredBufferScaleSinceVersion = 6;
    /// wayland protocol version introducing WlSurface.onPreferredBufferTransform.
    enum onPreferredBufferTransformSinceVersion = 6;

    /// Event delegate signature of WlSurface.onEnter.
    alias OnEnterEventDg = void delegate(WlSurface wlSurface,
                                         WlOutput output);
    /// Event delegate signature of WlSurface.onLeave.
    alias OnLeaveEventDg = void delegate(WlSurface wlSurface,
                                         WlOutput output);
    /// Event delegate signature of WlSurface.onPreferredBufferScale.
    alias OnPreferredBufferScaleEventDg = void delegate(WlSurface wlSurface,
                                                        int factor);
    /// Event delegate signature of WlSurface.onPreferredBufferTransform.
    alias OnPreferredBufferTransformEventDg = void delegate(WlSurface wlSurface,
                                                            WlOutput.Transform transform);

    /++
     +  wl_surface error values
     +
     +  These errors can be emitted in response to wl_surface requests.
     +/
    enum Error : uint
    {
        /// buffer scale value is invalid
        invalidScale = 0,
        /// buffer transform value is invalid
        invalidTransform = 1,
        /// buffer size is invalid
        invalidSize = 2,
        /// buffer offset is invalid
        invalidOffset = 3,
        /// surface was destroyed before its role object
        defunctRoleObject = 4,
    }

    /++
     +  delete surface
     +
     +  Deletes the surface and invalidates its object ID.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  set the surface contents
     +
     +  Set a buffer as the content of this surface.
     +
     +  The new size of the surface is calculated based on the buffer
     +  size transformed by the inverse buffer_transform and the
     +  inverse buffer_scale. This means that at commit time the supplied
     +  buffer size must be an integer multiple of the buffer_scale. If
     +  that's not the case, an invalid_size error is sent.
     +
     +  The x and y arguments specify the location of the new pending
     +  buffer's upper left corner, relative to the current buffer's upper
     +  left corner, in surface-local coordinates. In other words, the
     +  x and y, combined with the new surface size define in which
     +  directions the surface's size changes. Setting anything other than 0
     +  as x and y arguments is discouraged, and should instead be replaced
     +  with using the separate wl_surface.offset request.
     +
     +  When the bound wl_surface version is 5 or higher, passing any
     +  non-zero x or y is a protocol violation, and will result in an
     +  'invalid_offset' error being raised. The x and y arguments are ignored
     +  and do not change the pending state. To achieve equivalent semantics,
     +  use wl_surface.offset.
     +
     +  Surface contents are double-buffered state, see wl_surface.commit.
     +
     +  The initial surface contents are void; there is no content.
     +  wl_surface.attach assigns the given wl_buffer as the pending
     +  wl_buffer. wl_surface.commit makes the pending wl_buffer the new
     +  surface contents, and the size of the surface becomes the size
     +  calculated from the wl_buffer, as described above. After commit,
     +  there is no pending buffer until the next attach.
     +
     +  Committing a pending wl_buffer allows the compositor to read the
     +  pixels in the wl_buffer. The compositor may access the pixels at
     +  any time after the wl_surface.commit request. When the compositor
     +  will not access the pixels anymore, it will send the
     +  wl_buffer.release event. Only after receiving wl_buffer.release,
     +  the client may reuse the wl_buffer. A wl_buffer that has been
     +  attached and then replaced by another attach instead of committed
     +  will not receive a release event, and is not used by the
     +  compositor.
     +
     +  If a pending wl_buffer has been committed to more than one wl_surface,
     +  the delivery of wl_buffer.release events becomes undefined. A well
     +  behaved client should not rely on wl_buffer.release events in this
     +  case. Alternatively, a client could create multiple wl_buffer objects
     +  from the same backing storage or use wp_linux_buffer_release.
     +
     +  Destroying the wl_buffer after wl_buffer.release does not change
     +  the surface contents. Destroying the wl_buffer before wl_buffer.release
     +  is allowed as long as the underlying buffer storage isn't re-used $(LPAREN)this
     +  can happen e.g. on client process termination$(RPAREN). However, if the client
     +  destroys the wl_buffer before receiving the wl_buffer.release event and
     +  mutates the underlying buffer storage, the surface contents become
     +  undefined immediately.
     +
     +  If wl_surface.attach is sent with a NULL wl_buffer, the
     +  following wl_surface.commit will remove the surface content.
     +
     +  If a pending wl_buffer has been destroyed, the result is not specified.
     +  Many compositors are known to remove the surface content on the following
     +  wl_surface.commit, but this behaviour is not universal. Clients seeking to
     +  maximise compatibility should not destroy pending buffers and should
     +  ensure that they explicitly remove content from surfaces, even after
     +  destroying buffers.
     +/
    void attach(WlBuffer buffer,
                int x,
                int y)
    {
        wl_proxy_marshal(
            proxy, attachOpCode, buffer.proxy, x, y
        );
    }

    /++
     +  mark part of the surface damaged
     +
     +  This request is used to describe the regions where the pending
     +  buffer is different from the current surface contents, and where
     +  the surface therefore needs to be repainted. The compositor
     +  ignores the parts of the damage that fall outside of the surface.
     +
     +  Damage is double-buffered state, see wl_surface.commit.
     +
     +  The damage rectangle is specified in surface-local coordinates,
     +  where x and y specify the upper left corner of the damage rectangle.
     +
     +  The initial value for pending damage is empty: no damage.
     +  wl_surface.damage adds pending damage: the new pending damage
     +  is the union of old pending damage and the given rectangle.
     +
     +  wl_surface.commit assigns pending damage as the current damage,
     +  and clears pending damage. The server will clear the current
     +  damage as it repaints the surface.
     +
     +  Note! New clients should not use this request. Instead damage can be
     +  posted with wl_surface.damage_buffer which uses buffer coordinates
     +  instead of surface coordinates.
     +/
    void damage(int x,
                int y,
                int width,
                int height)
    {
        wl_proxy_marshal(
            proxy, damageOpCode, x, y, width, height
        );
    }

    /++
     +  request a frame throttling hint
     +
     +  Request a notification when it is a good time to start drawing a new
     +  frame, by creating a frame callback. This is useful for throttling
     +  redrawing operations, and driving animations.
     +
     +  When a client is animating on a wl_surface, it can use the 'frame'
     +  request to get notified when it is a good time to draw and commit the
     +  next frame of animation. If the client commits an update earlier than
     +  that, it is likely that some updates will not make it to the display,
     +  and the client is wasting resources by drawing too often.
     +
     +  The frame request will take effect on the next wl_surface.commit.
     +  The notification will only be posted for one frame unless
     +  requested again. For a wl_surface, the notifications are posted in
     +  the order the frame requests were committed.
     +
     +  The server must send the notifications so that a client
     +  will not send excessive updates, while still allowing
     +  the highest possible update rate for clients that wait for the reply
     +  before drawing again. The server should give some time for the client
     +  to draw and commit after sending the frame callback events to let it
     +  hit the next output refresh.
     +
     +  A server should avoid signaling the frame callbacks if the
     +  surface is not visible in any way, e.g. the surface is off-screen,
     +  or completely obscured by other opaque surfaces.
     +
     +  The object returned by this request will be destroyed by the
     +  compositor after the callback is fired and as such the client must not
     +  attempt to use it after that point.
     +
     +  The callback_data passed in the callback is the current time, in
     +  milliseconds, with an undefined base.
     +/
    WlCallback frame()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, frameOpCode, WlCallback.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlCallback)_p;
        return new WlCallback(_pp);
    }

    /++
     +  set opaque region
     +
     +  This request sets the region of the surface that contains
     +  opaque content.
     +
     +  The opaque region is an optimization hint for the compositor
     +  that lets it optimize the redrawing of content behind opaque
     +  regions.  Setting an opaque region is not required for correct
     +  behaviour, but marking transparent content as opaque will result
     +  in repaint artifacts.
     +
     +  The opaque region is specified in surface-local coordinates.
     +
     +  The compositor ignores the parts of the opaque region that fall
     +  outside of the surface.
     +
     +  Opaque region is double-buffered state, see wl_surface.commit.
     +
     +  wl_surface.set_opaque_region changes the pending opaque region.
     +  wl_surface.commit copies the pending region to the current region.
     +  Otherwise, the pending and current regions are never changed.
     +
     +  The initial value for an opaque region is empty. Setting the pending
     +  opaque region has copy semantics, and the wl_region object can be
     +  destroyed immediately. A NULL wl_region causes the pending opaque
     +  region to be set to empty.
     +/
    void setOpaqueRegion(WlRegion region)
    {
        wl_proxy_marshal(
            proxy, setOpaqueRegionOpCode, region.proxy
        );
    }

    /++
     +  set input region
     +
     +  This request sets the region of the surface that can receive
     +  pointer and touch events.
     +
     +  Input events happening outside of this region will try the next
     +  surface in the server surface stack. The compositor ignores the
     +  parts of the input region that fall outside of the surface.
     +
     +  The input region is specified in surface-local coordinates.
     +
     +  Input region is double-buffered state, see wl_surface.commit.
     +
     +  wl_surface.set_input_region changes the pending input region.
     +  wl_surface.commit copies the pending region to the current region.
     +  Otherwise the pending and current regions are never changed,
     +  except cursor and icon surfaces are special cases, see
     +  wl_pointer.set_cursor and wl_data_device.start_drag.
     +
     +  The initial value for an input region is infinite. That means the
     +  whole surface will accept input. Setting the pending input region
     +  has copy semantics, and the wl_region object can be destroyed
     +  immediately. A NULL wl_region causes the input region to be set
     +  to infinite.
     +/
    void setInputRegion(WlRegion region)
    {
        wl_proxy_marshal(
            proxy, setInputRegionOpCode, region.proxy
        );
    }

    /++
     +  commit pending surface state
     +
     +  Surface state $(LPAREN)input, opaque, and damage regions, attached buffers,
     +  etc.$(RPAREN) is double-buffered. Protocol requests modify the pending state,
     +  as opposed to the active state in use by the compositor.
     +
     +  A commit request atomically creates a content update from the pending
     +  state, even if the pending state has not been touched. The content
     +  update is placed in a queue until it becomes active. After commit, the
     +  new pending state is as documented for each related request.
     +
     +  When the content update is applied, the wl_buffer is applied before all
     +  other state. This means that all coordinates in double-buffered state
     +  are relative to the newly attached wl_buffers, except for
     +  wl_surface.attach itself. If there is no newly attached wl_buffer, the
     +  coordinates are relative to the previous content update.
     +
     +  All requests that need a commit to become effective are documented
     +  to affect double-buffered state.
     +
     +  Other interfaces may add further double-buffered surface state.
     +/
    void commit()
    {
        wl_proxy_marshal(
            proxy, commitOpCode
        );
    }

    /++
     +  sets the buffer transformation
     +
     +  This request sets the transformation that the client has already applied
     +  to the content of the buffer. The accepted values for the transform
     +  parameter are the values for wl_output.transform.
     +
     +  The compositor applies the inverse of this transformation whenever it
     +  uses the buffer contents.
     +
     +  Buffer transform is double-buffered state, see wl_surface.commit.
     +
     +  A newly created surface has its buffer transformation set to normal.
     +
     +  wl_surface.set_buffer_transform changes the pending buffer
     +  transformation. wl_surface.commit copies the pending buffer
     +  transformation to the current one. Otherwise, the pending and current
     +  values are never changed.
     +
     +  The purpose of this request is to allow clients to render content
     +  according to the output transform, thus permitting the compositor to
     +  use certain optimizations even if the display is rotated. Using
     +  hardware overlays and scanning out a client buffer for fullscreen
     +  surfaces are examples of such optimizations. Those optimizations are
     +  highly dependent on the compositor implementation, so the use of this
     +  request should be considered on a case-by-case basis.
     +
     +  Note that if the transform value includes 90 or 270 degree rotation,
     +  the width of the buffer will become the surface height and the height
     +  of the buffer will become the surface width.
     +
     +  If transform is not one of the values from the
     +  wl_output.transform enum the invalid_transform protocol error
     +  is raised.
     +/
    void setBufferTransform(int transform)
    {
        wl_proxy_marshal(
            proxy, setBufferTransformOpCode, transform
        );
    }

    /++
     +  sets the buffer scaling factor
     +
     +  This request sets an optional scaling factor on how the compositor
     +  interprets the contents of the buffer attached to the window.
     +
     +  Buffer scale is double-buffered state, see wl_surface.commit.
     +
     +  A newly created surface has its buffer scale set to 1.
     +
     +  wl_surface.set_buffer_scale changes the pending buffer scale.
     +  wl_surface.commit copies the pending buffer scale to the current one.
     +  Otherwise, the pending and current values are never changed.
     +
     +  The purpose of this request is to allow clients to supply higher
     +  resolution buffer data for use on high resolution outputs. It is
     +  intended that you pick the same buffer scale as the scale of the
     +  output that the surface is displayed on. This means the compositor
     +  can avoid scaling when rendering the surface on that output.
     +
     +  Note that if the scale is larger than 1, then you have to attach
     +  a buffer that is larger $(LPAREN)by a factor of scale in each dimension$(RPAREN)
     +  than the desired surface size.
     +
     +  If scale is not greater than 0 the invalid_scale protocol error is
     +  raised.
     +/
    void setBufferScale(int scale)
    {
        wl_proxy_marshal(
            proxy, setBufferScaleOpCode, scale
        );
    }

    /++
     +  mark part of the surface damaged using buffer coordinates
     +
     +  This request is used to describe the regions where the pending
     +  buffer is different from the current surface contents, and where
     +  the surface therefore needs to be repainted. The compositor
     +  ignores the parts of the damage that fall outside of the surface.
     +
     +  Damage is double-buffered state, see wl_surface.commit.
     +
     +  The damage rectangle is specified in buffer coordinates,
     +  where x and y specify the upper left corner of the damage rectangle.
     +
     +  The initial value for pending damage is empty: no damage.
     +  wl_surface.damage_buffer adds pending damage: the new pending
     +  damage is the union of old pending damage and the given rectangle.
     +
     +  wl_surface.commit assigns pending damage as the current damage,
     +  and clears pending damage. The server will clear the current
     +  damage as it repaints the surface.
     +
     +  This request differs from wl_surface.damage in only one way - it
     +  takes damage in buffer coordinates instead of surface-local
     +  coordinates. While this generally is more intuitive than surface
     +  coordinates, it is especially desirable when using wp_viewport
     +  or when a drawing library $(LPAREN)like EGL$(RPAREN) is unaware of buffer scale
     +  and buffer transform.
     +
     +  Note: Because buffer transformation changes and damage requests may
     +  be interleaved in the protocol stream, it is impossible to determine
     +  the actual mapping between surface and buffer damage until
     +  wl_surface.commit time. Therefore, compositors wishing to take both
     +  kinds of damage into account will have to accumulate damage from the
     +  two requests separately and only transform from one to the other
     +  after receiving the wl_surface.commit.
     +/
    void damageBuffer(int x,
                      int y,
                      int width,
                      int height)
    {
        wl_proxy_marshal(
            proxy, damageBufferOpCode, x, y, width, height
        );
    }

    /++
     +  set the surface contents offset
     +
     +  The x and y arguments specify the location of the new pending
     +  buffer's upper left corner, relative to the current buffer's upper
     +  left corner, in surface-local coordinates. In other words, the
     +  x and y, combined with the new surface size define in which
     +  directions the surface's size changes.
     +
     +  Surface location offset is double-buffered state, see
     +  wl_surface.commit.
     +
     +  This request is semantically equivalent to and the replaces the x and y
     +  arguments in the wl_surface.attach request in wl_surface versions prior
     +  to 5. See wl_surface.attach for details.
     +/
    void offset(int x,
                int y)
    {
        wl_proxy_marshal(
            proxy, offsetOpCode, x, y
        );
    }

    /++
     +  surface enters an output
     +
     +  This is emitted whenever a surface's creation, movement, or resizing
     +  results in some part of it being within the scanout region of an
     +  output.
     +
     +  Note that a surface may be overlapping with zero or more outputs.
     +/
    @property void onEnter(OnEnterEventDg dg)
    {
        _onEnter = dg;
    }

    /++
     +  surface leaves an output
     +
     +  This is emitted whenever a surface's creation, movement, or resizing
     +  results in it no longer having any part of it within the scanout region
     +  of an output.
     +
     +  Clients should not use the number of outputs the surface is on for frame
     +  throttling purposes. The surface might be hidden even if no leave event
     +  has been sent, and the compositor might expect new surface content
     +  updates even if no enter event has been sent. The frame event should be
     +  used instead.
     +/
    @property void onLeave(OnLeaveEventDg dg)
    {
        _onLeave = dg;
    }

    /++
     +  preferred buffer scale for the surface
     +
     +  This event indicates the preferred buffer scale for this surface. It is
     +  sent whenever the compositor's preference changes.
     +
     +  Before receiving this event the preferred buffer scale for this surface
     +  is 1.
     +
     +  It is intended that scaling aware clients use this event to scale their
     +  content and use wl_surface.set_buffer_scale to indicate the scale they
     +  have rendered with. This allows clients to supply a higher detail
     +  buffer.
     +
     +  The compositor shall emit a scale value greater than 0.
     +/
    @property void onPreferredBufferScale(OnPreferredBufferScaleEventDg dg)
    {
        _onPreferredBufferScale = dg;
    }

    /++
     +  preferred buffer transform for the surface
     +
     +  This event indicates the preferred buffer transform for this surface.
     +  It is sent whenever the compositor's preference changes.
     +
     +  Before receiving this event the preferred buffer transform for this
     +  surface is normal.
     +
     +  Applying this transformation to the surface buffer contents and using
     +  wl_surface.set_buffer_transform might allow the compositor to use the
     +  surface buffer more efficiently.
     +/
    @property void onPreferredBufferTransform(OnPreferredBufferTransformEventDg dg)
    {
        _onPreferredBufferTransform = dg;
    }

    private OnEnterEventDg _onEnter;
    private OnLeaveEventDg _onLeave;
    private OnPreferredBufferScaleEventDg _onPreferredBufferScale;
    private OnPreferredBufferTransformEventDg _onPreferredBufferTransform;
}

/++
 +  group of input devices
 +
 +  A seat is a group of keyboards, pointer and touch devices. This
 +  object is published as a global during start up, or when such a
 +  device is hot plugged.  A seat typically has a pointer and
 +  maintains a keyboard focus and a pointer focus.
 +/
final class WlSeat : WlProxy
{
    /// Version of wayland.wl_seat
    enum ver = 9;

    /// Build a WlSeat from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_seat_listener, cast(void*) this);
    }

    /// Interface object that creates WlSeat objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlSeatIface;
    }

    /// Op-code of WlSeat.getPointer.
    enum getPointerOpCode = 0;
    /// Op-code of WlSeat.getKeyboard.
    enum getKeyboardOpCode = 1;
    /// Op-code of WlSeat.getTouch.
    enum getTouchOpCode = 2;
    /// Op-code of WlSeat.release.
    enum releaseOpCode = 3;

    /// Version of wayland protocol introducing WlSeat.getPointer.
    enum getPointerSinceVersion = 1;
    /// Version of wayland protocol introducing WlSeat.getKeyboard.
    enum getKeyboardSinceVersion = 1;
    /// Version of wayland protocol introducing WlSeat.getTouch.
    enum getTouchSinceVersion = 1;
    /// Version of wayland protocol introducing WlSeat.release.
    enum releaseSinceVersion = 5;

    /// wayland protocol version introducing WlSeat.onCapabilities.
    enum onCapabilitiesSinceVersion = 1;
    /// wayland protocol version introducing WlSeat.onName.
    enum onNameSinceVersion = 2;

    /// Event delegate signature of WlSeat.onCapabilities.
    alias OnCapabilitiesEventDg = void delegate(WlSeat wlSeat,
                                                Capability capabilities);
    /// Event delegate signature of WlSeat.onName.
    alias OnNameEventDg = void delegate(WlSeat wlSeat,
                                        string name);

    /++
     +  seat capability bitmask
     +
     +  This is a bitmask of capabilities this seat has; if a member is
     +  set, then it is present on the seat.
     +/
    enum Capability : uint
    {
        /// the seat has pointer devices
        pointer = 1,
        /// the seat has one or more keyboards
        keyboard = 2,
        /// the seat has touch devices
        touch = 4,
    }

    /++
     +  wl_seat error values
     +
     +  These errors can be emitted in response to wl_seat requests.
     +/
    enum Error : uint
    {
        /// get_pointer, get_keyboard or get_touch called on seat without the matching capability
        missingCapability = 0,
    }

    /// Destroy this WlSeat object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  return pointer object
     +
     +  The ID provided will be initialized to the wl_pointer interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the pointer
     +  capability, or has had the pointer capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the pointer capability. The missing_capability error will
     +  be sent in this case.
     +/
    WlPointer getPointer()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getPointerOpCode, WlPointer.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlPointer)_p;
        return new WlPointer(_pp);
    }

    /++
     +  return keyboard object
     +
     +  The ID provided will be initialized to the wl_keyboard interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the keyboard
     +  capability, or has had the keyboard capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the keyboard capability. The missing_capability error will
     +  be sent in this case.
     +/
    WlKeyboard getKeyboard()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getKeyboardOpCode, WlKeyboard.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlKeyboard)_p;
        return new WlKeyboard(_pp);
    }

    /++
     +  return touch object
     +
     +  The ID provided will be initialized to the wl_touch interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the touch
     +  capability, or has had the touch capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the touch capability. The missing_capability error will
     +  be sent in this case.
     +/
    WlTouch getTouch()
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getTouchOpCode, WlTouch.iface.native, null
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlTouch)_p;
        return new WlTouch(_pp);
    }

    /++
     +  release the seat object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the seat object anymore.
     +/
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  seat capabilities changed
     +
     +  This is emitted whenever a seat gains or loses the pointer,
     +  keyboard or touch capabilities.  The argument is a capability
     +  enum containing the complete set of capabilities this seat has.
     +
     +  When the pointer capability is added, a client may create a
     +  wl_pointer object using the wl_seat.get_pointer request. This object
     +  will receive pointer events until the capability is removed in the
     +  future.
     +
     +  When the pointer capability is removed, a client should destroy the
     +  wl_pointer objects associated with the seat where the capability was
     +  removed, using the wl_pointer.release request. No further pointer
     +  events will be received on these objects.
     +
     +  In some compositors, if a seat regains the pointer capability and a
     +  client has a previously obtained wl_pointer object of version 4 or
     +  less, that object may start sending pointer events again. This
     +  behavior is considered a misinterpretation of the intended behavior
     +  and must not be relied upon by the client. wl_pointer objects of
     +  version 5 or later must not send events if created before the most
     +  recent event notifying the client of an added pointer capability.
     +
     +  The above behavior also applies to wl_keyboard and wl_touch with the
     +  keyboard and touch capabilities, respectively.
     +/
    @property void onCapabilities(OnCapabilitiesEventDg dg)
    {
        _onCapabilities = dg;
    }

    /++
     +  unique identifier for this seat
     +
     +  In a multi-seat configuration the seat name can be used by clients to
     +  help identify which physical devices the seat represents.
     +
     +  The seat name is a UTF-8 string with no convention defined for its
     +  contents. Each name is unique among all wl_seat globals. The name is
     +  only guaranteed to be unique for the current compositor instance.
     +
     +  The same seat names are used for all clients. Thus, the name can be
     +  shared across processes to refer to a specific wl_seat global.
     +
     +  The name event is sent after binding to the seat global. This event is
     +  only sent once per seat object, and the name does not change over the
     +  lifetime of the wl_seat global.
     +
     +  Compositors may re-use the same seat name if the wl_seat global is
     +  destroyed and re-created later.
     +/
    @property void onName(OnNameEventDg dg)
    {
        _onName = dg;
    }

    private OnCapabilitiesEventDg _onCapabilities;
    private OnNameEventDg _onName;
}

/++
 +  pointer input device
 +
 +  The wl_pointer interface represents one or more input devices,
 +  such as mice, which control the pointer location and pointer_focus
 +  of a seat.
 +
 +  The wl_pointer interface generates motion, enter and leave
 +  events for the surfaces that the pointer is located over,
 +  and button and axis events for button presses, button releases
 +  and scrolling.
 +/
final class WlPointer : WlProxy
{
    /// Version of wayland.wl_pointer
    enum ver = 9;

    /// Build a WlPointer from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_pointer_listener, cast(void*) this);
    }

    /// Interface object that creates WlPointer objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlPointerIface;
    }

    /// Op-code of WlPointer.setCursor.
    enum setCursorOpCode = 0;
    /// Op-code of WlPointer.release.
    enum releaseOpCode = 1;

    /// Version of wayland protocol introducing WlPointer.setCursor.
    enum setCursorSinceVersion = 1;
    /// Version of wayland protocol introducing WlPointer.release.
    enum releaseSinceVersion = 3;

    /// wayland protocol version introducing WlPointer.onEnter.
    enum onEnterSinceVersion = 1;
    /// wayland protocol version introducing WlPointer.onLeave.
    enum onLeaveSinceVersion = 1;
    /// wayland protocol version introducing WlPointer.onMotion.
    enum onMotionSinceVersion = 1;
    /// wayland protocol version introducing WlPointer.onButton.
    enum onButtonSinceVersion = 1;
    /// wayland protocol version introducing WlPointer.onAxis.
    enum onAxisSinceVersion = 1;
    /// wayland protocol version introducing WlPointer.onFrame.
    enum onFrameSinceVersion = 5;
    /// wayland protocol version introducing WlPointer.onAxisSource.
    enum onAxisSourceSinceVersion = 5;
    /// wayland protocol version introducing WlPointer.onAxisStop.
    enum onAxisStopSinceVersion = 5;
    /// wayland protocol version introducing WlPointer.onAxisDiscrete.
    enum onAxisDiscreteSinceVersion = 5;
    /// wayland protocol version introducing WlPointer.onAxisValue120.
    enum onAxisValue120SinceVersion = 8;
    /// wayland protocol version introducing WlPointer.onAxisRelativeDirection.
    enum onAxisRelativeDirectionSinceVersion = 9;

    /// Event delegate signature of WlPointer.onEnter.
    alias OnEnterEventDg = void delegate(WlPointer wlPointer,
                                         uint serial,
                                         WlSurface surface,
                                         WlFixed surfaceX,
                                         WlFixed surfaceY);
    /// Event delegate signature of WlPointer.onLeave.
    alias OnLeaveEventDg = void delegate(WlPointer wlPointer,
                                         uint serial,
                                         WlSurface surface);
    /// Event delegate signature of WlPointer.onMotion.
    alias OnMotionEventDg = void delegate(WlPointer wlPointer,
                                          uint time,
                                          WlFixed surfaceX,
                                          WlFixed surfaceY);
    /// Event delegate signature of WlPointer.onButton.
    alias OnButtonEventDg = void delegate(WlPointer wlPointer,
                                          uint serial,
                                          uint time,
                                          uint button,
                                          ButtonState state);
    /// Event delegate signature of WlPointer.onAxis.
    alias OnAxisEventDg = void delegate(WlPointer wlPointer,
                                        uint time,
                                        Axis axis,
                                        WlFixed value);
    /// Event delegate signature of WlPointer.onFrame.
    alias OnFrameEventDg = void delegate(WlPointer wlPointer);
    /// Event delegate signature of WlPointer.onAxisSource.
    alias OnAxisSourceEventDg = void delegate(WlPointer wlPointer,
                                              AxisSource axisSource);
    /// Event delegate signature of WlPointer.onAxisStop.
    alias OnAxisStopEventDg = void delegate(WlPointer wlPointer,
                                            uint time,
                                            Axis axis);
    /// Event delegate signature of WlPointer.onAxisDiscrete.
    alias OnAxisDiscreteEventDg = void delegate(WlPointer wlPointer,
                                                Axis axis,
                                                int discrete);
    /// Event delegate signature of WlPointer.onAxisValue120.
    alias OnAxisValue120EventDg = void delegate(WlPointer wlPointer,
                                                Axis axis,
                                                int value120);
    /// Event delegate signature of WlPointer.onAxisRelativeDirection.
    alias OnAxisRelativeDirectionEventDg = void delegate(WlPointer wlPointer,
                                                         Axis axis,
                                                         AxisRelativeDirection direction);

    enum Error : uint
    {
        /// given wl_surface has another role
        role = 0,
    }

    /++
     +  physical button state
     +
     +  Describes the physical state of a button that produced the button
     +  event.
     +/
    enum ButtonState : uint
    {
        /// the button is not pressed
        released = 0,
        /// the button is pressed
        pressed = 1,
    }

    /++
     +  axis types
     +
     +  Describes the axis types of scroll events.
     +/
    enum Axis : uint
    {
        /// vertical axis
        verticalScroll = 0,
        /// horizontal axis
        horizontalScroll = 1,
    }

    /++
     +  axis source types
     +
     +  Describes the source types for axis events. This indicates to the
     +  client how an axis event was physically generated; a client may
     +  adjust the user interface accordingly. For example, scroll events
     +  from a "finger" source may be in a smooth coordinate space with
     +  kinetic scrolling whereas a "wheel" source may be in discrete steps
     +  of a number of lines.
     +
     +  The "continuous" axis source is a device generating events in a
     +  continuous coordinate space, but using something other than a
     +  finger. One example for this source is button-based scrolling where
     +  the vertical motion of a device is converted to scroll events while
     +  a button is held down.
     +
     +  The "wheel tilt" axis source indicates that the actual device is a
     +  wheel but the scroll event is not caused by a rotation but a
     +  $(LPAREN)usually sideways$(RPAREN) tilt of the wheel.
     +/
    enum AxisSource : uint
    {
        /// a physical wheel rotation
        wheel = 0,
        /// finger on a touch surface
        finger = 1,
        /// continuous coordinate space
        continuous = 2,
        /// a physical wheel tilt
        wheelTilt = 3,
    }

    /++
     +  axis relative direction
     +
     +  This specifies the direction of the physical motion that caused a
     +  wl_pointer.axis event, relative to the wl_pointer.axis direction.
     +/
    enum AxisRelativeDirection : uint
    {
        /// physical motion matches axis direction
        identical = 0,
        /// physical motion is the inverse of the axis direction
        inverted = 1,
    }

    /// Destroy this WlPointer object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  set the pointer surface
     +
     +  Set the pointer surface, i.e., the surface that contains the
     +  pointer image $(LPAREN)cursor$(RPAREN). This request gives the surface the role
     +  of a cursor. If the surface already has another role, it raises
     +  a protocol error.
     +
     +  The cursor actually changes only if the pointer
     +  focus for this device is one of the requesting client's surfaces
     +  or the surface parameter is the current pointer surface. If
     +  there was a previous surface set with this request it is
     +  replaced. If surface is NULL, the pointer image is hidden.
     +
     +  The parameters hotspot_x and hotspot_y define the position of
     +  the pointer surface relative to the pointer location. Its
     +  top-left corner is always at $(LPAREN)x, y$(RPAREN) - $(LPAREN)hotspot_x, hotspot_y$(RPAREN),
     +  where $(LPAREN)x, y$(RPAREN) are the coordinates of the pointer location, in
     +  surface-local coordinates.
     +
     +  On wl_surface.offset requests to the pointer surface, hotspot_x
     +  and hotspot_y are decremented by the x and y parameters
     +  passed to the request. The offset must be applied by
     +  wl_surface.commit as usual.
     +
     +  The hotspot can also be updated by passing the currently set
     +  pointer surface to this request with new values for hotspot_x
     +  and hotspot_y.
     +
     +  The input region is ignored for wl_surfaces with the role of
     +  a cursor. When the use as a cursor ends, the wl_surface is
     +  unmapped.
     +
     +  The serial parameter must match the latest wl_pointer.enter
     +  serial number sent to the client. Otherwise the request will be
     +  ignored.
     +/
    void setCursor(uint serial,
                   WlSurface surface,
                   int hotspotX,
                   int hotspotY)
    {
        wl_proxy_marshal(
            proxy, setCursorOpCode, serial, surface.proxy, hotspotX, hotspotY
        );
    }

    /++
     +  release the pointer object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the pointer object anymore.
     +
     +  This request destroys the pointer proxy object, so clients must not call
     +  wl_pointer_destroy$(LPAREN)$(RPAREN) after using this request.
     +/
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  enter event
     +
     +  Notification that this seat's pointer is focused on a certain
     +  surface.
     +
     +  When a seat's focus enters a surface, the pointer image
     +  is undefined and a client should respond to this event by setting
     +  an appropriate pointer image with the set_cursor request.
     +/
    @property void onEnter(OnEnterEventDg dg)
    {
        _onEnter = dg;
    }

    /++
     +  leave event
     +
     +  Notification that this seat's pointer is no longer focused on
     +  a certain surface.
     +
     +  The leave notification is sent before the enter notification
     +  for the new focus.
     +/
    @property void onLeave(OnLeaveEventDg dg)
    {
        _onLeave = dg;
    }

    /++
     +  pointer motion event
     +
     +  Notification of pointer location change. The arguments
     +  surface_x and surface_y are the location relative to the
     +  focused surface.
     +/
    @property void onMotion(OnMotionEventDg dg)
    {
        _onMotion = dg;
    }

    /++
     +  pointer button event
     +
     +  Mouse button click and release notifications.
     +
     +  The location of the click is given by the last motion or
     +  enter event.
     +  The time argument is a timestamp with millisecond
     +  granularity, with an undefined base.
     +
     +  The button is a button code as defined in the Linux kernel's
     +  linux/input-event-codes.h header file, e.g. BTN_LEFT.
     +
     +  Any 16-bit button code value is reserved for future additions to the
     +  kernel's event code list. All other button codes above 0xFFFF are
     +  currently undefined but may be used in future versions of this
     +  protocol.
     +/
    @property void onButton(OnButtonEventDg dg)
    {
        _onButton = dg;
    }

    /++
     +  axis event
     +
     +  Scroll and other axis notifications.
     +
     +  For scroll events $(LPAREN)vertical and horizontal scroll axes$(RPAREN), the
     +  value parameter is the length of a vector along the specified
     +  axis in a coordinate space identical to those of motion events,
     +  representing a relative movement along the specified axis.
     +
     +  For devices that support movements non-parallel to axes multiple
     +  axis events will be emitted.
     +
     +  When applicable, for example for touch pads, the server can
     +  choose to emit scroll events where the motion vector is
     +  equivalent to a motion event vector.
     +
     +  When applicable, a client can transform its content relative to the
     +  scroll distance.
     +/
    @property void onAxis(OnAxisEventDg dg)
    {
        _onAxis = dg;
    }

    /++
     +  end of a pointer event sequence
     +
     +  Indicates the end of a set of events that logically belong together.
     +  A client is expected to accumulate the data in all events within the
     +  frame before proceeding.
     +
     +  All wl_pointer events before a wl_pointer.frame event belong
     +  logically together. For example, in a diagonal scroll motion the
     +  compositor will send an optional wl_pointer.axis_source event, two
     +  wl_pointer.axis events $(LPAREN)horizontal and vertical$(RPAREN) and finally a
     +  wl_pointer.frame event. The client may use this information to
     +  calculate a diagonal vector for scrolling.
     +
     +  When multiple wl_pointer.axis events occur within the same frame,
     +  the motion vector is the combined motion of all events.
     +  When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
     +  the same frame, this indicates that axis movement in one axis has
     +  stopped but continues in the other axis.
     +  When multiple wl_pointer.axis_stop events occur within the same
     +  frame, this indicates that these axes stopped in the same instance.
     +
     +  A wl_pointer.frame event is sent for every logical event group,
     +  even if the group only contains a single wl_pointer event.
     +  Specifically, a client may get a sequence: motion, frame, button,
     +  frame, axis, frame, axis_stop, frame.
     +
     +  The wl_pointer.enter and wl_pointer.leave events are logical events
     +  generated by the compositor and not the hardware. These events are
     +  also grouped by a wl_pointer.frame. When a pointer moves from one
     +  surface to another, a compositor should group the
     +  wl_pointer.leave event within the same wl_pointer.frame.
     +  However, a client must not rely on wl_pointer.leave and
     +  wl_pointer.enter being in the same wl_pointer.frame.
     +  Compositor-specific policies may require the wl_pointer.leave and
     +  wl_pointer.enter event being split across multiple wl_pointer.frame
     +  groups.
     +/
    @property void onFrame(OnFrameEventDg dg)
    {
        _onFrame = dg;
    }

    /++
     +  axis source event
     +
     +  Source information for scroll and other axes.
     +
     +  This event does not occur on its own. It is sent before a
     +  wl_pointer.frame event and carries the source information for
     +  all events within that frame.
     +
     +  The source specifies how this event was generated. If the source is
     +  wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
     +  sent when the user lifts the finger off the device.
     +
     +  If the source is wl_pointer.axis_source.wheel,
     +  wl_pointer.axis_source.wheel_tilt or
     +  wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
     +  or may not be sent. Whether a compositor sends an axis_stop event
     +  for these sources is hardware-specific and implementation-dependent;
     +  clients must not rely on receiving an axis_stop event for these
     +  scroll sources and should treat scroll sequences from these scroll
     +  sources as unterminated by default.
     +
     +  This event is optional. If the source is unknown for a particular
     +  axis event sequence, no event is sent.
     +  Only one wl_pointer.axis_source event is permitted per frame.
     +
     +  The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
     +  not guaranteed.
     +/
    @property void onAxisSource(OnAxisSourceEventDg dg)
    {
        _onAxisSource = dg;
    }

    /++
     +  axis stop event
     +
     +  Stop notification for scroll and other axes.
     +
     +  For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
     +  is sent to notify a client that the axis sequence has terminated.
     +  This enables the client to implement kinetic scrolling.
     +  See the wl_pointer.axis_source documentation for information on when
     +  this event may be generated.
     +
     +  Any wl_pointer.axis events with the same axis_source after this
     +  event should be considered as the start of a new axis motion.
     +
     +  The timestamp is to be interpreted identical to the timestamp in the
     +  wl_pointer.axis event. The timestamp value may be the same as a
     +  preceding wl_pointer.axis event.
     +/
    @property void onAxisStop(OnAxisStopEventDg dg)
    {
        _onAxisStop = dg;
    }

    /++
     +  axis click event
     +
     +  Discrete step information for scroll and other axes.
     +
     +  This event carries the axis value of the wl_pointer.axis event in
     +  discrete steps $(LPAREN)e.g. mouse wheel clicks$(RPAREN).
     +
     +  This event is deprecated with wl_pointer version 8 - this event is not
     +  sent to clients supporting version 8 or later.
     +
     +  This event does not occur on its own, it is coupled with a
     +  wl_pointer.axis event that represents this axis value on a
     +  continuous scale. The protocol guarantees that each axis_discrete
     +  event is always followed by exactly one axis event with the same
     +  axis number within the same wl_pointer.frame. Note that the protocol
     +  allows for other events to occur between the axis_discrete and
     +  its coupled axis event, including other axis_discrete or axis
     +  events. A wl_pointer.frame must not contain more than one axis_discrete
     +  event per axis type.
     +
     +  This event is optional; continuous scrolling devices
     +  like two-finger scrolling on touchpads do not have discrete
     +  steps and do not generate this event.
     +
     +  The discrete value carries the directional information. e.g. a value
     +  of -2 is two steps towards the negative direction of this axis.
     +
     +  The axis number is identical to the axis number in the associated
     +  axis event.
     +
     +  The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
     +  not guaranteed.
     +/
    @property void onAxisDiscrete(OnAxisDiscreteEventDg dg)
    {
        _onAxisDiscrete = dg;
    }

    /++
     +  axis high-resolution scroll event
     +
     +  Discrete high-resolution scroll information.
     +
     +  This event carries high-resolution wheel scroll information,
     +  with each multiple of 120 representing one logical scroll step
     +  $(LPAREN)a wheel detent$(RPAREN). For example, an axis_value120 of 30 is one quarter of
     +  a logical scroll step in the positive direction, a value120 of
     +  -240 are two logical scroll steps in the negative direction within the
     +  same hardware event.
     +  Clients that rely on discrete scrolling should accumulate the
     +  value120 to multiples of 120 before processing the event.
     +
     +  The value120 must not be zero.
     +
     +  This event replaces the wl_pointer.axis_discrete event in clients
     +  supporting wl_pointer version 8 or later.
     +
     +  Where a wl_pointer.axis_source event occurs in the same
     +  wl_pointer.frame, the axis source applies to this event.
     +
     +  The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
     +  not guaranteed.
     +/
    @property void onAxisValue120(OnAxisValue120EventDg dg)
    {
        _onAxisValue120 = dg;
    }

    /++
     +  axis relative physical direction event
     +
     +  Relative directional information of the entity causing the axis
     +  motion.
     +
     +  For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
     +  event specifies the movement direction of the entity causing the
     +  wl_pointer.axis event. For example:
     +  - if a user's fingers on a touchpad move down and this
     +    causes a wl_pointer.axis vertical_scroll down event, the physical
     +    direction is 'identical'
     +  - if a user's fingers on a touchpad move down and this causes a
     +    wl_pointer.axis vertical_scroll up scroll up event $(LPAREN)'natural
     +    scrolling'$(RPAREN), the physical direction is 'inverted'.
     +
     +  A client may use this information to adjust scroll motion of
     +  components. Specifically, enabling natural scrolling causes the
     +  content to change direction compared to traditional scrolling.
     +  Some widgets like volume control sliders should usually match the
     +  physical direction regardless of whether natural scrolling is
     +  active. This event enables clients to match the scroll direction of
     +  a widget to the physical direction.
     +
     +  This event does not occur on its own, it is coupled with a
     +  wl_pointer.axis event that represents this axis value.
     +  The protocol guarantees that each axis_relative_direction event is
     +  always followed by exactly one axis event with the same
     +  axis number within the same wl_pointer.frame. Note that the protocol
     +  allows for other events to occur between the axis_relative_direction
     +  and its coupled axis event.
     +
     +  The axis number is identical to the axis number in the associated
     +  axis event.
     +
     +  The order of wl_pointer.axis_relative_direction,
     +  wl_pointer.axis_discrete and wl_pointer.axis_source is not
     +  guaranteed.
     +/
    @property void onAxisRelativeDirection(OnAxisRelativeDirectionEventDg dg)
    {
        _onAxisRelativeDirection = dg;
    }

    private OnEnterEventDg _onEnter;
    private OnLeaveEventDg _onLeave;
    private OnMotionEventDg _onMotion;
    private OnButtonEventDg _onButton;
    private OnAxisEventDg _onAxis;
    private OnFrameEventDg _onFrame;
    private OnAxisSourceEventDg _onAxisSource;
    private OnAxisStopEventDg _onAxisStop;
    private OnAxisDiscreteEventDg _onAxisDiscrete;
    private OnAxisValue120EventDg _onAxisValue120;
    private OnAxisRelativeDirectionEventDg _onAxisRelativeDirection;
}

/++
 +  keyboard input device
 +
 +  The wl_keyboard interface represents one or more keyboards
 +  associated with a seat.
 +
 +  Each wl_keyboard has the following logical state:
 +
 +  - an active surface $(LPAREN)possibly null$(RPAREN),
 +  - the keys currently logically down,
 +  - the active modifiers,
 +  - the active group.
 +
 +  By default, the active surface is null, the keys currently logically down
 +  are empty, the active modifiers and the active group are 0.
 +/
final class WlKeyboard : WlProxy
{
    /// Version of wayland.wl_keyboard
    enum ver = 9;

    /// Build a WlKeyboard from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_keyboard_listener, cast(void*) this);
    }

    /// Interface object that creates WlKeyboard objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlKeyboardIface;
    }

    /// Op-code of WlKeyboard.release.
    enum releaseOpCode = 0;

    /// Version of wayland protocol introducing WlKeyboard.release.
    enum releaseSinceVersion = 3;

    /// wayland protocol version introducing WlKeyboard.onKeymap.
    enum onKeymapSinceVersion = 1;
    /// wayland protocol version introducing WlKeyboard.onEnter.
    enum onEnterSinceVersion = 1;
    /// wayland protocol version introducing WlKeyboard.onLeave.
    enum onLeaveSinceVersion = 1;
    /// wayland protocol version introducing WlKeyboard.onKey.
    enum onKeySinceVersion = 1;
    /// wayland protocol version introducing WlKeyboard.onModifiers.
    enum onModifiersSinceVersion = 1;
    /// wayland protocol version introducing WlKeyboard.onRepeatInfo.
    enum onRepeatInfoSinceVersion = 4;

    /// Event delegate signature of WlKeyboard.onKeymap.
    alias OnKeymapEventDg = void delegate(WlKeyboard wlKeyboard,
                                          KeymapFormat format,
                                          int fd,
                                          uint size);
    /// Event delegate signature of WlKeyboard.onEnter.
    alias OnEnterEventDg = void delegate(WlKeyboard wlKeyboard,
                                         uint serial,
                                         WlSurface surface,
                                         wl_array* keys);
    /// Event delegate signature of WlKeyboard.onLeave.
    alias OnLeaveEventDg = void delegate(WlKeyboard wlKeyboard,
                                         uint serial,
                                         WlSurface surface);
    /// Event delegate signature of WlKeyboard.onKey.
    alias OnKeyEventDg = void delegate(WlKeyboard wlKeyboard,
                                       uint serial,
                                       uint time,
                                       uint key,
                                       KeyState state);
    /// Event delegate signature of WlKeyboard.onModifiers.
    alias OnModifiersEventDg = void delegate(WlKeyboard wlKeyboard,
                                             uint serial,
                                             uint modsDepressed,
                                             uint modsLatched,
                                             uint modsLocked,
                                             uint group);
    /// Event delegate signature of WlKeyboard.onRepeatInfo.
    alias OnRepeatInfoEventDg = void delegate(WlKeyboard wlKeyboard,
                                              int rate,
                                              int delay);

    /++
     +  keyboard mapping format
     +
     +  This specifies the format of the keymap provided to the
     +  client with the wl_keyboard.keymap event.
     +/
    enum KeymapFormat : uint
    {
        /// no keymap; client must understand how to interpret the raw keycode
        noKeymap = 0,
        /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
        xkbV1 = 1,
    }

    /++
     +  physical key state
     +
     +  Describes the physical state of a key that produced the key event.
     +/
    enum KeyState : uint
    {
        /// key is not pressed
        released = 0,
        /// key is pressed
        pressed = 1,
    }

    /// Destroy this WlKeyboard object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /// release the keyboard object
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  keyboard mapping
     +
     +  This event provides a file descriptor to the client which can be
     +  memory-mapped in read-only mode to provide a keyboard mapping
     +  description.
     +
     +  From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
     +  the recipient, as MAP_SHARED may fail.
     +/
    @property void onKeymap(OnKeymapEventDg dg)
    {
        _onKeymap = dg;
    }

    /++
     +  enter event
     +
     +  Notification that this seat's keyboard focus is on a certain
     +  surface.
     +
     +  The compositor must send the wl_keyboard.modifiers event after this
     +  event.
     +
     +  In the wl_keyboard logical state, this event sets the active surface to
     +  the surface argument and the keys currently logically down to the keys
     +  in the keys argument. The compositor must not send this event if the
     +  wl_keyboard already had an active surface immediately before this event.
     +/
    @property void onEnter(OnEnterEventDg dg)
    {
        _onEnter = dg;
    }

    /++
     +  leave event
     +
     +  Notification that this seat's keyboard focus is no longer on
     +  a certain surface.
     +
     +  The leave notification is sent before the enter notification
     +  for the new focus.
     +
     +  In the wl_keyboard logical state, this event resets all values to their
     +  defaults. The compositor must not send this event if the active surface
     +  of the wl_keyboard was not equal to the surface argument immediately
     +  before this event.
     +/
    @property void onLeave(OnLeaveEventDg dg)
    {
        _onLeave = dg;
    }

    /++
     +  key event
     +
     +  A key was pressed or released.
     +  The time argument is a timestamp with millisecond
     +  granularity, with an undefined base.
     +
     +  The key is a platform-specific key code that can be interpreted
     +  by feeding it to the keyboard mapping $(LPAREN)see the keymap event$(RPAREN).
     +
     +  If this event produces a change in modifiers, then the resulting
     +  wl_keyboard.modifiers event must be sent after this event.
     +
     +  In the wl_keyboard logical state, this event adds the key to the keys
     +  currently logically down $(LPAREN)if the state argument is pressed$(RPAREN) or removes
     +  the key from the keys currently logically down $(LPAREN)if the state argument is
     +  released$(RPAREN). The compositor must not send this event if the wl_keyboard
     +  did not have an active surface immediately before this event. The
     +  compositor must not send this event if state is pressed $(LPAREN)resp. released$(RPAREN)
     +  and the key was already logically down $(LPAREN)resp. was not logically down$(RPAREN)
     +  immediately before this event.
     +/
    @property void onKey(OnKeyEventDg dg)
    {
        _onKey = dg;
    }

    /++
     +  modifier and group state
     +
     +  Notifies clients that the modifier and/or group state has
     +  changed, and it should update its local state.
     +
     +  The compositor may send this event without a surface of the client
     +  having keyboard focus, for example to tie modifier information to
     +  pointer focus instead. If a modifier event with pressed modifiers is sent
     +  without a prior enter event, the client can assume the modifier state is
     +  valid until it receives the next wl_keyboard.modifiers event. In order to
     +  reset the modifier state again, the compositor can send a
     +  wl_keyboard.modifiers event with no pressed modifiers.
     +
     +  In the wl_keyboard logical state, this event updates the modifiers and
     +  group.
     +/
    @property void onModifiers(OnModifiersEventDg dg)
    {
        _onModifiers = dg;
    }

    /++
     +  repeat rate and delay
     +
     +  Informs the client about the keyboard's repeat rate and delay.
     +
     +  This event is sent as soon as the wl_keyboard object has been created,
     +  and is guaranteed to be received by the client before any key press
     +  event.
     +
     +  Negative values for either rate or delay are illegal. A rate of zero
     +  will disable any repeating $(LPAREN)regardless of the value of delay$(RPAREN).
     +
     +  This event can be sent later on as well with a new value if necessary,
     +  so clients should continue listening for the event past the creation
     +  of wl_keyboard.
     +/
    @property void onRepeatInfo(OnRepeatInfoEventDg dg)
    {
        _onRepeatInfo = dg;
    }

    private OnKeymapEventDg _onKeymap;
    private OnEnterEventDg _onEnter;
    private OnLeaveEventDg _onLeave;
    private OnKeyEventDg _onKey;
    private OnModifiersEventDg _onModifiers;
    private OnRepeatInfoEventDg _onRepeatInfo;
}

/++
 +  touchscreen input device
 +
 +  The wl_touch interface represents a touchscreen
 +  associated with a seat.
 +
 +  Touch interactions can consist of one or more contacts.
 +  For each contact, a series of events is generated, starting
 +  with a down event, followed by zero or more motion events,
 +  and ending with an up event. Events relating to the same
 +  contact point can be identified by the ID of the sequence.
 +/
final class WlTouch : WlProxy
{
    /// Version of wayland.wl_touch
    enum ver = 9;

    /// Build a WlTouch from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_touch_listener, cast(void*) this);
    }

    /// Interface object that creates WlTouch objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlTouchIface;
    }

    /// Op-code of WlTouch.release.
    enum releaseOpCode = 0;

    /// Version of wayland protocol introducing WlTouch.release.
    enum releaseSinceVersion = 3;

    /// wayland protocol version introducing WlTouch.onDown.
    enum onDownSinceVersion = 1;
    /// wayland protocol version introducing WlTouch.onUp.
    enum onUpSinceVersion = 1;
    /// wayland protocol version introducing WlTouch.onMotion.
    enum onMotionSinceVersion = 1;
    /// wayland protocol version introducing WlTouch.onFrame.
    enum onFrameSinceVersion = 1;
    /// wayland protocol version introducing WlTouch.onCancel.
    enum onCancelSinceVersion = 1;
    /// wayland protocol version introducing WlTouch.onShape.
    enum onShapeSinceVersion = 6;
    /// wayland protocol version introducing WlTouch.onOrientation.
    enum onOrientationSinceVersion = 6;

    /// Event delegate signature of WlTouch.onDown.
    alias OnDownEventDg = void delegate(WlTouch wlTouch,
                                        uint serial,
                                        uint time,
                                        WlSurface surface,
                                        int id,
                                        WlFixed x,
                                        WlFixed y);
    /// Event delegate signature of WlTouch.onUp.
    alias OnUpEventDg = void delegate(WlTouch wlTouch,
                                      uint serial,
                                      uint time,
                                      int id);
    /// Event delegate signature of WlTouch.onMotion.
    alias OnMotionEventDg = void delegate(WlTouch wlTouch,
                                          uint time,
                                          int id,
                                          WlFixed x,
                                          WlFixed y);
    /// Event delegate signature of WlTouch.onFrame.
    alias OnFrameEventDg = void delegate(WlTouch wlTouch);
    /// Event delegate signature of WlTouch.onCancel.
    alias OnCancelEventDg = void delegate(WlTouch wlTouch);
    /// Event delegate signature of WlTouch.onShape.
    alias OnShapeEventDg = void delegate(WlTouch wlTouch,
                                         int id,
                                         WlFixed major,
                                         WlFixed minor);
    /// Event delegate signature of WlTouch.onOrientation.
    alias OnOrientationEventDg = void delegate(WlTouch wlTouch,
                                               int id,
                                               WlFixed orientation);

    /// Destroy this WlTouch object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /// release the touch object
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  touch down event and beginning of a touch sequence
     +
     +  A new touch point has appeared on the surface. This touch point is
     +  assigned a unique ID. Future events from this touch point reference
     +  this ID. The ID ceases to be valid after a touch up event and may be
     +  reused in the future.
     +/
    @property void onDown(OnDownEventDg dg)
    {
        _onDown = dg;
    }

    /++
     +  end of a touch event sequence
     +
     +  The touch point has disappeared. No further events will be sent for
     +  this touch point and the touch point's ID is released and may be
     +  reused in a future touch down event.
     +/
    @property void onUp(OnUpEventDg dg)
    {
        _onUp = dg;
    }

    /++
     +  update of touch point coordinates
     +
     +  A touch point has changed coordinates.
     +/
    @property void onMotion(OnMotionEventDg dg)
    {
        _onMotion = dg;
    }

    /++
     +  end of touch frame event
     +
     +  Indicates the end of a set of events that logically belong together.
     +  A client is expected to accumulate the data in all events within the
     +  frame before proceeding.
     +
     +  A wl_touch.frame terminates at least one event but otherwise no
     +  guarantee is provided about the set of events within a frame. A client
     +  must assume that any state not updated in a frame is unchanged from the
     +  previously known state.
     +/
    @property void onFrame(OnFrameEventDg dg)
    {
        _onFrame = dg;
    }

    /++
     +  touch session cancelled
     +
     +  Sent if the compositor decides the touch stream is a global
     +  gesture. No further events are sent to the clients from that
     +  particular gesture. Touch cancellation applies to all touch points
     +  currently active on this client's surface. The client is
     +  responsible for finalizing the touch points, future touch points on
     +  this surface may reuse the touch point ID.
     +
     +  No frame event is required after the cancel event.
     +/
    @property void onCancel(OnCancelEventDg dg)
    {
        _onCancel = dg;
    }

    /++
     +  update shape of touch point
     +
     +  Sent when a touchpoint has changed its shape.
     +
     +  This event does not occur on its own. It is sent before a
     +  wl_touch.frame event and carries the new shape information for
     +  any previously reported, or new touch points of that frame.
     +
     +  Other events describing the touch point such as wl_touch.down,
     +  wl_touch.motion or wl_touch.orientation may be sent within the
     +  same wl_touch.frame. A client should treat these events as a single
     +  logical touch point update. The order of wl_touch.shape,
     +  wl_touch.orientation and wl_touch.motion is not guaranteed.
     +  A wl_touch.down event is guaranteed to occur before the first
     +  wl_touch.shape event for this touch ID but both events may occur within
     +  the same wl_touch.frame.
     +
     +  A touchpoint shape is approximated by an ellipse through the major and
     +  minor axis length. The major axis length describes the longer diameter
     +  of the ellipse, while the minor axis length describes the shorter
     +  diameter. Major and minor are orthogonal and both are specified in
     +  surface-local coordinates. The center of the ellipse is always at the
     +  touchpoint location as reported by wl_touch.down or wl_touch.move.
     +
     +  This event is only sent by the compositor if the touch device supports
     +  shape reports. The client has to make reasonable assumptions about the
     +  shape if it did not receive this event.
     +/
    @property void onShape(OnShapeEventDg dg)
    {
        _onShape = dg;
    }

    /++
     +  update orientation of touch point
     +
     +  Sent when a touchpoint has changed its orientation.
     +
     +  This event does not occur on its own. It is sent before a
     +  wl_touch.frame event and carries the new shape information for
     +  any previously reported, or new touch points of that frame.
     +
     +  Other events describing the touch point such as wl_touch.down,
     +  wl_touch.motion or wl_touch.shape may be sent within the
     +  same wl_touch.frame. A client should treat these events as a single
     +  logical touch point update. The order of wl_touch.shape,
     +  wl_touch.orientation and wl_touch.motion is not guaranteed.
     +  A wl_touch.down event is guaranteed to occur before the first
     +  wl_touch.orientation event for this touch ID but both events may occur
     +  within the same wl_touch.frame.
     +
     +  The orientation describes the clockwise angle of a touchpoint's major
     +  axis to the positive surface y-axis and is normalized to the -180 to
     +  +180 degree range. The granularity of orientation depends on the touch
     +  device, some devices only support binary rotation values between 0 and
     +  90 degrees.
     +
     +  This event is only sent by the compositor if the touch device supports
     +  orientation reports.
     +/
    @property void onOrientation(OnOrientationEventDg dg)
    {
        _onOrientation = dg;
    }

    private OnDownEventDg _onDown;
    private OnUpEventDg _onUp;
    private OnMotionEventDg _onMotion;
    private OnFrameEventDg _onFrame;
    private OnCancelEventDg _onCancel;
    private OnShapeEventDg _onShape;
    private OnOrientationEventDg _onOrientation;
}

/++
 +  compositor output region
 +
 +  An output describes part of the compositor geometry.  The
 +  compositor works in the 'compositor coordinate system' and an
 +  output corresponds to a rectangular area in that space that is
 +  actually visible.  This typically corresponds to a monitor that
 +  displays part of the compositor space.  This object is published
 +  as global during start up, or when a monitor is hotplugged.
 +/
final class WlOutput : WlProxy
{
    /// Version of wayland.wl_output
    enum ver = 4;

    /// Build a WlOutput from a native object.
    private this(wl_proxy* native)
    {
        super(native);
        wl_proxy_add_listener(proxy, cast(void_func_t*)&wl_d_wl_output_listener, cast(void*) this);
    }

    /// Interface object that creates WlOutput objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlOutputIface;
    }

    /// Op-code of WlOutput.release.
    enum releaseOpCode = 0;

    /// Version of wayland protocol introducing WlOutput.release.
    enum releaseSinceVersion = 3;

    /// wayland protocol version introducing WlOutput.onGeometry.
    enum onGeometrySinceVersion = 1;
    /// wayland protocol version introducing WlOutput.onMode.
    enum onModeSinceVersion = 1;
    /// wayland protocol version introducing WlOutput.onDone.
    enum onDoneSinceVersion = 2;
    /// wayland protocol version introducing WlOutput.onScale.
    enum onScaleSinceVersion = 2;
    /// wayland protocol version introducing WlOutput.onName.
    enum onNameSinceVersion = 4;
    /// wayland protocol version introducing WlOutput.onDescription.
    enum onDescriptionSinceVersion = 4;

    /// Event delegate signature of WlOutput.onGeometry.
    alias OnGeometryEventDg = void delegate(WlOutput wlOutput,
                                            int x,
                                            int y,
                                            int physicalWidth,
                                            int physicalHeight,
                                            int subpixel,
                                            string make,
                                            string model,
                                            int transform);
    /// Event delegate signature of WlOutput.onMode.
    alias OnModeEventDg = void delegate(WlOutput wlOutput,
                                        Mode flags,
                                        int width,
                                        int height,
                                        int refresh);
    /// Event delegate signature of WlOutput.onDone.
    alias OnDoneEventDg = void delegate(WlOutput wlOutput);
    /// Event delegate signature of WlOutput.onScale.
    alias OnScaleEventDg = void delegate(WlOutput wlOutput,
                                         int factor);
    /// Event delegate signature of WlOutput.onName.
    alias OnNameEventDg = void delegate(WlOutput wlOutput,
                                        string name);
    /// Event delegate signature of WlOutput.onDescription.
    alias OnDescriptionEventDg = void delegate(WlOutput wlOutput,
                                               string description);

    /++
     +  subpixel geometry information
     +
     +  This enumeration describes how the physical
     +  pixels on an output are laid out.
     +/
    enum Subpixel : uint
    {
        /// unknown geometry
        unknown = 0,
        /// no geometry
        none = 1,
        /// horizontal RGB
        horizontalRgb = 2,
        /// horizontal BGR
        horizontalBgr = 3,
        /// vertical RGB
        verticalRgb = 4,
        /// vertical BGR
        verticalBgr = 5,
    }

    /++
     +  transformation applied to buffer contents
     +
     +  This describes transformations that clients and compositors apply to
     +  buffer contents.
     +
     +  The flipped values correspond to an initial flip around a
     +  vertical axis followed by rotation.
     +
     +  The purpose is mainly to allow clients to render accordingly and
     +  tell the compositor, so that for fullscreen surfaces, the
     +  compositor will still be able to scan out directly from client
     +  surfaces.
     +/
    enum Transform : uint
    {
        /// no transform
        normal = 0,
        /// 90 degrees counter-clockwise
        _90 = 1,
        /// 180 degrees counter-clockwise
        _180 = 2,
        /// 270 degrees counter-clockwise
        _270 = 3,
        /// 180 degree flip around a vertical axis
        flipped = 4,
        /// flip and rotate 90 degrees counter-clockwise
        flipped90 = 5,
        /// flip and rotate 180 degrees counter-clockwise
        flipped180 = 6,
        /// flip and rotate 270 degrees counter-clockwise
        flipped270 = 7,
    }

    /++
     +  mode information
     +
     +  These flags describe properties of an output mode.
     +  They are used in the flags bitfield of the mode event.
     +/
    enum Mode : uint
    {
        /// indicates this is the current mode
        current = 0x1,
        /// indicates this is the preferred mode
        preferred = 0x2,
    }

    /// Destroy this WlOutput object.
    void destroy()
    {
        wl_proxy_destroy(proxy);
        super.destroyNotify();
    }

    /++
     +  release the output object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the output object anymore.
     +/
    void release()
    {
        wl_proxy_marshal(
            proxy, releaseOpCode
        );
        super.destroyNotify();
    }

    /++
     +  properties of the output
     +
     +  The geometry event describes geometric properties of the output.
     +  The event is sent when binding to the output object and whenever
     +  any of the properties change.
     +
     +  The physical size can be set to zero if it doesn't make sense for this
     +  output $(LPAREN)e.g. for projectors or virtual outputs$(RPAREN).
     +
     +  The geometry event will be followed by a done event $(LPAREN)starting from
     +  version 2$(RPAREN).
     +
     +  Clients should use wl_surface.preferred_buffer_transform instead of the
     +  transform advertised by this event to find the preferred buffer
     +  transform to use for a surface.
     +
     +  Note: wl_output only advertises partial information about the output
     +  position and identification. Some compositors, for instance those not
     +  implementing a desktop-style output layout or those exposing virtual
     +  outputs, might fake this information. Instead of using x and y, clients
     +  should use xdg_output.logical_position. Instead of using make and model,
     +  clients should use name and description.
     +/
    @property void onGeometry(OnGeometryEventDg dg)
    {
        _onGeometry = dg;
    }

    /++
     +  advertise available modes for the output
     +
     +  The mode event describes an available mode for the output.
     +
     +  The event is sent when binding to the output object and there
     +  will always be one mode, the current mode.  The event is sent
     +  again if an output changes mode, for the mode that is now
     +  current.  In other words, the current mode is always the last
     +  mode that was received with the current flag set.
     +
     +  Non-current modes are deprecated. A compositor can decide to only
     +  advertise the current mode and never send other modes. Clients
     +  should not rely on non-current modes.
     +
     +  The size of a mode is given in physical hardware units of
     +  the output device. This is not necessarily the same as
     +  the output size in the global compositor space. For instance,
     +  the output may be scaled, as described in wl_output.scale,
     +  or transformed, as described in wl_output.transform. Clients
     +  willing to retrieve the output size in the global compositor
     +  space should use xdg_output.logical_size instead.
     +
     +  The vertical refresh rate can be set to zero if it doesn't make
     +  sense for this output $(LPAREN)e.g. for virtual outputs$(RPAREN).
     +
     +  The mode event will be followed by a done event $(LPAREN)starting from
     +  version 2$(RPAREN).
     +
     +  Clients should not use the refresh rate to schedule frames. Instead,
     +  they should use the wl_surface.frame event or the presentation-time
     +  protocol.
     +
     +  Note: this information is not always meaningful for all outputs. Some
     +  compositors, such as those exposing virtual outputs, might fake the
     +  refresh rate or the size.
     +/
    @property void onMode(OnModeEventDg dg)
    {
        _onMode = dg;
    }

    /++
     +  sent all information about output
     +
     +  This event is sent after all other properties have been
     +  sent after binding to the output object and after any
     +  other property changes done after that. This allows
     +  changes to the output properties to be seen as
     +  atomic, even if they happen via multiple events.
     +/
    @property void onDone(OnDoneEventDg dg)
    {
        _onDone = dg;
    }

    /++
     +  output scaling properties
     +
     +  This event contains scaling geometry information
     +  that is not in the geometry event. It may be sent after
     +  binding the output object or if the output scale changes
     +  later. The compositor will emit a non-zero, positive
     +  value for scale. If it is not sent, the client should
     +  assume a scale of 1.
     +
     +  A scale larger than 1 means that the compositor will
     +  automatically scale surface buffers by this amount
     +  when rendering. This is used for very high resolution
     +  displays where applications rendering at the native
     +  resolution would be too small to be legible.
     +
     +  Clients should use wl_surface.preferred_buffer_scale
     +  instead of this event to find the preferred buffer
     +  scale to use for a surface.
     +
     +  The scale event will be followed by a done event.
     +/
    @property void onScale(OnScaleEventDg dg)
    {
        _onScale = dg;
    }

    /++
     +  name of this output
     +
     +  Many compositors will assign user-friendly names to their outputs, show
     +  them to the user, allow the user to refer to an output, etc. The client
     +  may wish to know this name as well to offer the user similar behaviors.
     +
     +  The name is a UTF-8 string with no convention defined for its contents.
     +  Each name is unique among all wl_output globals. The name is only
     +  guaranteed to be unique for the compositor instance.
     +
     +  The same output name is used for all clients for a given wl_output
     +  global. Thus, the name can be shared across processes to refer to a
     +  specific wl_output global.
     +
     +  The name is not guaranteed to be persistent across sessions, thus cannot
     +  be used to reliably identify an output in e.g. configuration files.
     +
     +  Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
     +  not assume that the name is a reflection of an underlying DRM connector,
     +  X11 connection, etc.
     +
     +  The name event is sent after binding the output object. This event is
     +  only sent once per output object, and the name does not change over the
     +  lifetime of the wl_output global.
     +
     +  Compositors may re-use the same output name if the wl_output global is
     +  destroyed and re-created later. Compositors should avoid re-using the
     +  same name if possible.
     +
     +  The name event will be followed by a done event.
     +/
    @property void onName(OnNameEventDg dg)
    {
        _onName = dg;
    }

    /++
     +  human-readable description of this output
     +
     +  Many compositors can produce human-readable descriptions of their
     +  outputs. The client may wish to know this description as well, e.g. for
     +  output selection purposes.
     +
     +  The description is a UTF-8 string with no convention defined for its
     +  contents. The description is not guaranteed to be unique among all
     +  wl_output globals. Examples might include 'Foocorp 11" Display' or
     +  'Virtual X11 output via :1'.
     +
     +  The description event is sent after binding the output object and
     +  whenever the description changes. The description is optional, and may
     +  not be sent at all.
     +
     +  The description event will be followed by a done event.
     +/
    @property void onDescription(OnDescriptionEventDg dg)
    {
        _onDescription = dg;
    }

    private OnGeometryEventDg _onGeometry;
    private OnModeEventDg _onMode;
    private OnDoneEventDg _onDone;
    private OnScaleEventDg _onScale;
    private OnNameEventDg _onName;
    private OnDescriptionEventDg _onDescription;
}

/++
 +  region interface
 +
 +  A region object describes an area.
 +
 +  Region objects are used to describe the opaque and input
 +  regions of a surface.
 +/
final class WlRegion : WlProxy
{
    /// Version of wayland.wl_region
    enum ver = 1;

    /// Build a WlRegion from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlRegion objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlRegionIface;
    }

    /// Op-code of WlRegion.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WlRegion.add.
    enum addOpCode = 1;
    /// Op-code of WlRegion.subtract.
    enum subtractOpCode = 2;

    /// Version of wayland protocol introducing WlRegion.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlRegion.add.
    enum addSinceVersion = 1;
    /// Version of wayland protocol introducing WlRegion.subtract.
    enum subtractSinceVersion = 1;

    /++
     +  destroy region
     +
     +  Destroy the region.  This will invalidate the object ID.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  add rectangle to region
     +
     +  Add the specified rectangle to the region.
     +/
    void add(int x,
             int y,
             int width,
             int height)
    {
        wl_proxy_marshal(
            proxy, addOpCode, x, y, width, height
        );
    }

    /++
     +  subtract rectangle from region
     +
     +  Subtract the specified rectangle from the region.
     +/
    void subtract(int x,
                  int y,
                  int width,
                  int height)
    {
        wl_proxy_marshal(
            proxy, subtractOpCode, x, y, width, height
        );
    }
}

/++
 +  sub-surface compositing
 +
 +  The global interface exposing sub-surface compositing capabilities.
 +  A wl_surface, that has sub-surfaces associated, is called the
 +  parent surface. Sub-surfaces can be arbitrarily nested and create
 +  a tree of sub-surfaces.
 +
 +  The root surface in a tree of sub-surfaces is the main
 +  surface. The main surface cannot be a sub-surface, because
 +  sub-surfaces must always have a parent.
 +
 +  A main surface with its sub-surfaces forms a $(LPAREN)compound$(RPAREN) window.
 +  For window management purposes, this set of wl_surface objects is
 +  to be considered as a single window, and it should also behave as
 +  such.
 +
 +  The aim of sub-surfaces is to offload some of the compositing work
 +  within a window from clients to the compositor. A prime example is
 +  a video player with decorations and video in separate wl_surface
 +  objects. This should allow the compositor to pass YUV video buffer
 +  processing to dedicated overlay hardware when possible.
 +/
final class WlSubcompositor : WlProxy
{
    /// Version of wayland.wl_subcompositor
    enum ver = 1;

    /// Build a WlSubcompositor from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlSubcompositor objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlSubcompositorIface;
    }

    /// Op-code of WlSubcompositor.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WlSubcompositor.getSubsurface.
    enum getSubsurfaceOpCode = 1;

    /// Version of wayland protocol introducing WlSubcompositor.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlSubcompositor.getSubsurface.
    enum getSubsurfaceSinceVersion = 1;

    enum Error : uint
    {
        /// the to-be sub-surface is invalid
        badSurface = 0,
        /// the to-be sub-surface parent is invalid
        badParent = 1,
    }

    /++
     +  unbind from the subcompositor interface
     +
     +  Informs the server that the client will not be using this
     +  protocol object anymore. This does not affect any other
     +  objects, wl_subsurface objects included.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  give a surface the role sub-surface
     +
     +  Create a sub-surface interface for the given surface, and
     +  associate it with the given parent surface. This turns a
     +  plain wl_surface into a sub-surface.
     +
     +  The to-be sub-surface must not already have another role, and it
     +  must not have an existing wl_subsurface object. Otherwise the
     +  bad_surface protocol error is raised.
     +
     +  Adding sub-surfaces to a parent is a double-buffered operation on the
     +  parent $(LPAREN)see wl_surface.commit$(RPAREN). The effect of adding a sub-surface
     +  becomes visible on the next time the state of the parent surface is
     +  applied.
     +
     +  The parent surface must not be one of the child surface's descendants,
     +  and the parent must be different from the child surface, otherwise the
     +  bad_parent protocol error is raised.
     +
     +  This request modifies the behaviour of wl_surface.commit request on
     +  the sub-surface, see the documentation on wl_subsurface interface.
     +/
    WlSubsurface getSubsurface(WlSurface surface,
                               WlSurface parent)
    {
        auto _pp = wl_proxy_marshal_constructor(
            proxy, getSubsurfaceOpCode, WlSubsurface.iface.native, null,
            surface.proxy, parent.proxy
        );
        if (!_pp) return null;
        auto _p = wl_proxy_get_user_data(_pp);
        if (_p) return cast(WlSubsurface)_p;
        return new WlSubsurface(_pp);
    }
}

/++
 +  sub-surface interface to a wl_surface
 +
 +  An additional interface to a wl_surface object, which has been
 +  made a sub-surface. A sub-surface has one parent surface. A
 +  sub-surface's size and position are not limited to that of the parent.
 +  Particularly, a sub-surface is not automatically clipped to its
 +  parent's area.
 +
 +  A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 +  and the parent surface is mapped. The order of which one happens
 +  first is irrelevant. A sub-surface is hidden if the parent becomes
 +  hidden, or if a NULL wl_buffer is applied. These rules apply
 +  recursively through the tree of surfaces.
 +
 +  The behaviour of a wl_surface.commit request on a sub-surface
 +  depends on the sub-surface's mode. The possible modes are
 +  synchronized and desynchronized, see methods
 +  wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 +  mode caches the wl_surface state to be applied when the parent's
 +  state gets applied, and desynchronized mode applies the pending
 +  wl_surface state directly. A sub-surface is initially in the
 +  synchronized mode.
 +
 +  Sub-surfaces also have another kind of state, which is managed by
 +  wl_subsurface requests, as opposed to wl_surface requests. This
 +  state includes the sub-surface position relative to the parent
 +  surface $(LPAREN)wl_subsurface.set_position$(RPAREN), and the stacking order of
 +  the parent and its sub-surfaces $(LPAREN)wl_subsurface.place_above and
 +  .place_below$(RPAREN). This state is applied when the parent surface's
 +  wl_surface state is applied, regardless of the sub-surface's mode.
 +  As the exception, set_sync and set_desync are effective immediately.
 +
 +  The main surface can be thought to be always in desynchronized mode,
 +  since it does not have a parent in the sub-surfaces sense.
 +
 +  Even if a sub-surface is in desynchronized mode, it will behave as
 +  in synchronized mode, if its parent surface behaves as in
 +  synchronized mode. This rule is applied recursively throughout the
 +  tree of surfaces. This means, that one can set a sub-surface into
 +  synchronized mode, and then assume that all its child and grand-child
 +  sub-surfaces are synchronized, too, without explicitly setting them.
 +
 +  Destroying a sub-surface takes effect immediately. If you need to
 +  synchronize the removal of a sub-surface to the parent surface update,
 +  unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
 +  and then destroy the sub-surface.
 +
 +  If the parent wl_surface object is destroyed, the sub-surface is
 +  unmapped.
 +
 +  A sub-surface never has the keyboard focus of any seat.
 +
 +  The wl_surface.offset request is ignored: clients must use set_position
 +  instead to move the sub-surface.
 +/
final class WlSubsurface : WlProxy
{
    /// Version of wayland.wl_subsurface
    enum ver = 1;

    /// Build a WlSubsurface from a native object.
    private this(wl_proxy* native)
    {
        super(native);
    }

    /// Interface object that creates WlSubsurface objects.
    static @property immutable(WlProxyInterface) iface()
    {
        return wlSubsurfaceIface;
    }

    /// Op-code of WlSubsurface.destroy.
    enum destroyOpCode = 0;
    /// Op-code of WlSubsurface.setPosition.
    enum setPositionOpCode = 1;
    /// Op-code of WlSubsurface.placeAbove.
    enum placeAboveOpCode = 2;
    /// Op-code of WlSubsurface.placeBelow.
    enum placeBelowOpCode = 3;
    /// Op-code of WlSubsurface.setSync.
    enum setSyncOpCode = 4;
    /// Op-code of WlSubsurface.setDesync.
    enum setDesyncOpCode = 5;

    /// Version of wayland protocol introducing WlSubsurface.destroy.
    enum destroySinceVersion = 1;
    /// Version of wayland protocol introducing WlSubsurface.setPosition.
    enum setPositionSinceVersion = 1;
    /// Version of wayland protocol introducing WlSubsurface.placeAbove.
    enum placeAboveSinceVersion = 1;
    /// Version of wayland protocol introducing WlSubsurface.placeBelow.
    enum placeBelowSinceVersion = 1;
    /// Version of wayland protocol introducing WlSubsurface.setSync.
    enum setSyncSinceVersion = 1;
    /// Version of wayland protocol introducing WlSubsurface.setDesync.
    enum setDesyncSinceVersion = 1;

    enum Error : uint
    {
        /// wl_surface is not a sibling or the parent
        badSurface = 0,
    }

    /++
     +  remove sub-surface interface
     +
     +  The sub-surface interface is removed from the wl_surface object
     +  that was turned into a sub-surface with a
     +  wl_subcompositor.get_subsurface request. The wl_surface's association
     +  to the parent is deleted. The wl_surface is unmapped immediately.
     +/
    void destroy()
    {
        wl_proxy_marshal(
            proxy, destroyOpCode
        );
        super.destroyNotify();
    }

    /++
     +  reposition the sub-surface
     +
     +  This schedules a sub-surface position change.
     +  The sub-surface will be moved so that its origin $(LPAREN)top left
     +  corner pixel$(RPAREN) will be at the location x, y of the parent surface
     +  coordinate system. The coordinates are not restricted to the parent
     +  surface area. Negative values are allowed.
     +
     +  The scheduled coordinates will take effect whenever the state of the
     +  parent surface is applied.
     +
     +  If more than one set_position request is invoked by the client before
     +  the commit of the parent surface, the position of a new request always
     +  replaces the scheduled position from any previous request.
     +
     +  The initial position is 0, 0.
     +/
    void setPosition(int x,
                     int y)
    {
        wl_proxy_marshal(
            proxy, setPositionOpCode, x, y
        );
    }

    /++
     +  restack the sub-surface
     +
     +  This sub-surface is taken from the stack, and put back just
     +  above the reference surface, changing the z-order of the sub-surfaces.
     +  The reference surface must be one of the sibling surfaces, or the
     +  parent surface. Using any other surface, including this sub-surface,
     +  will cause a protocol error.
     +
     +  The z-order is double-buffered. Requests are handled in order and
     +  applied immediately to a pending state. The final pending state is
     +  copied to the active state the next time the state of the parent
     +  surface is applied.
     +
     +  A new sub-surface is initially added as the top-most in the stack
     +  of its siblings and parent.
     +/
    void placeAbove(WlSurface sibling)
    {
        wl_proxy_marshal(
            proxy, placeAboveOpCode, sibling.proxy
        );
    }

    /++
     +  restack the sub-surface
     +
     +  The sub-surface is placed just below the reference surface.
     +  See wl_subsurface.place_above.
     +/
    void placeBelow(WlSurface sibling)
    {
        wl_proxy_marshal(
            proxy, placeBelowOpCode, sibling.proxy
        );
    }

    /++
     +  set sub-surface to synchronized mode
     +
     +  Change the commit behaviour of the sub-surface to synchronized
     +  mode, also described as the parent dependent mode.
     +
     +  In synchronized mode, wl_surface.commit on a sub-surface will
     +  accumulate the committed state in a cache, but the state will
     +  not be applied and hence will not change the compositor output.
     +  The cached state is applied to the sub-surface immediately after
     +  the parent surface's state is applied. This ensures atomic
     +  updates of the parent and all its synchronized sub-surfaces.
     +  Applying the cached state will invalidate the cache, so further
     +  parent surface commits do not $(LPAREN)re-$(RPAREN)apply old state.
     +
     +  See wl_subsurface for the recursive effect of this mode.
     +/
    void setSync()
    {
        wl_proxy_marshal(
            proxy, setSyncOpCode
        );
    }

    /++
     +  set sub-surface to desynchronized mode
     +
     +  Change the commit behaviour of the sub-surface to desynchronized
     +  mode, also described as independent or freely running mode.
     +
     +  In desynchronized mode, wl_surface.commit on a sub-surface will
     +  apply the pending state directly, without caching, as happens
     +  normally with a wl_surface. Calling wl_surface.commit on the
     +  parent surface has no effect on the sub-surface's wl_surface
     +  state. This mode allows a sub-surface to be updated on its own.
     +
     +  If cached state exists when wl_surface.commit is called in
     +  desynchronized mode, the pending state is added to the cached
     +  state, and applied as a whole. This invalidates the cache.
     +
     +  Note: even if a sub-surface is set to desynchronized, a parent
     +  sub-surface may override it to behave as synchronized. For details,
     +  see wl_subsurface.
     +
     +  If a surface's parent surface behaves as desynchronized, then
     +  the cached state is applied on set_desync.
     +/
    void setDesync()
    {
        wl_proxy_marshal(
            proxy, setDesyncOpCode
        );
    }
}

private:

immutable WlProxyInterface wlDisplayIface;
immutable WlProxyInterface wlRegistryIface;
immutable WlProxyInterface wlCallbackIface;
immutable WlProxyInterface wlCompositorIface;
immutable WlProxyInterface wlShmPoolIface;
immutable WlProxyInterface wlShmIface;
immutable WlProxyInterface wlBufferIface;
immutable WlProxyInterface wlDataOfferIface;
immutable WlProxyInterface wlDataSourceIface;
immutable WlProxyInterface wlDataDeviceIface;
immutable WlProxyInterface wlDataDeviceManagerIface;
immutable WlProxyInterface wlShellIface;
immutable WlProxyInterface wlShellSurfaceIface;
immutable WlProxyInterface wlSurfaceIface;
immutable WlProxyInterface wlSeatIface;
immutable WlProxyInterface wlPointerIface;
immutable WlProxyInterface wlKeyboardIface;
immutable WlProxyInterface wlTouchIface;
immutable WlProxyInterface wlOutputIface;
immutable WlProxyInterface wlRegionIface;
immutable WlProxyInterface wlSubcompositorIface;
immutable WlProxyInterface wlSubsurfaceIface;

immutable final class WlDisplayIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlDisplay(cast(wl_display*)proxy);
    }
}

immutable final class WlRegistryIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlRegistry(proxy);
    }
}

immutable final class WlCallbackIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlCallback(proxy);
    }
}

immutable final class WlCompositorIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlCompositor(proxy);
    }
}

immutable final class WlShmPoolIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlShmPool(proxy);
    }
}

immutable final class WlShmIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlShm(proxy);
    }
}

immutable final class WlBufferIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlBuffer(proxy);
    }
}

immutable final class WlDataOfferIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlDataOffer(proxy);
    }
}

immutable final class WlDataSourceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlDataSource(proxy);
    }
}

immutable final class WlDataDeviceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlDataDevice(proxy);
    }
}

immutable final class WlDataDeviceManagerIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlDataDeviceManager(proxy);
    }
}

immutable final class WlShellIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlShell(proxy);
    }
}

immutable final class WlShellSurfaceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlShellSurface(proxy);
    }
}

immutable final class WlSurfaceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlSurface(proxy);
    }
}

immutable final class WlSeatIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlSeat(proxy);
    }
}

immutable final class WlPointerIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlPointer(proxy);
    }
}

immutable final class WlKeyboardIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlKeyboard(proxy);
    }
}

immutable final class WlTouchIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlTouch(proxy);
    }
}

immutable final class WlOutputIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlOutput(proxy);
    }
}

immutable final class WlRegionIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlRegion(proxy);
    }
}

immutable final class WlSubcompositorIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlSubcompositor(proxy);
    }
}

immutable final class WlSubsurfaceIface : WlProxyInterface
{
    this(immutable wl_interface* native)
    {
        super(native);
    }
    override WlProxy makeProxy(wl_proxy* proxy) immutable
    {
        return new WlSubsurface(proxy);
    }
}

immutable wl_interface[] wl_ifaces;

enum wlDisplayIndex = 0;
enum wlRegistryIndex = 1;
enum wlCallbackIndex = 2;
enum wlCompositorIndex = 3;
enum wlShmPoolIndex = 4;
enum wlShmIndex = 5;
enum wlBufferIndex = 6;
enum wlDataOfferIndex = 7;
enum wlDataSourceIndex = 8;
enum wlDataDeviceIndex = 9;
enum wlDataDeviceManagerIndex = 10;
enum wlShellIndex = 11;
enum wlShellSurfaceIndex = 12;
enum wlSurfaceIndex = 13;
enum wlSeatIndex = 14;
enum wlPointerIndex = 15;
enum wlKeyboardIndex = 16;
enum wlTouchIndex = 17;
enum wlOutputIndex = 18;
enum wlRegionIndex = 19;
enum wlSubcompositorIndex = 20;
enum wlSubsurfaceIndex = 21;

shared static this()
{
    auto ifaces = new wl_interface[22];

    auto msgTypes = [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        &ifaces[wlCallbackIndex],
        &ifaces[wlRegistryIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlRegionIndex],
        &ifaces[wlBufferIndex],
        null,
        null,
        null,
        null,
        null,
        &ifaces[wlShmPoolIndex],
        null,
        null,
        &ifaces[wlDataSourceIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlSurfaceIndex],
        null,
        &ifaces[wlDataSourceIndex],
        null,
        &ifaces[wlDataOfferIndex],
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        &ifaces[wlDataOfferIndex],
        &ifaces[wlDataOfferIndex],
        &ifaces[wlDataSourceIndex],
        &ifaces[wlDataDeviceIndex],
        &ifaces[wlSeatIndex],
        &ifaces[wlShellSurfaceIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlSeatIndex],
        null,
        &ifaces[wlSeatIndex],
        null,
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        null,
        null,
        null,
        &ifaces[wlOutputIndex],
        &ifaces[wlSeatIndex],
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        null,
        &ifaces[wlOutputIndex],
        &ifaces[wlBufferIndex],
        null,
        null,
        &ifaces[wlCallbackIndex],
        &ifaces[wlRegionIndex],
        &ifaces[wlRegionIndex],
        &ifaces[wlOutputIndex],
        &ifaces[wlOutputIndex],
        &ifaces[wlPointerIndex],
        &ifaces[wlKeyboardIndex],
        &ifaces[wlTouchIndex],
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        null,
        &ifaces[wlSurfaceIndex],
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        &ifaces[wlSurfaceIndex],
        null,
        null,
        null,
        &ifaces[wlSubsurfaceIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlSurfaceIndex],
        &ifaces[wlSurfaceIndex],
    ];

    auto wl_display_requests = [
        wl_message("sync", "n", &msgTypes[8]),
        wl_message("get_registry", "n", &msgTypes[9]),
    ];
    auto wl_display_events = [
        wl_message("error", "ous", &msgTypes[0]),
        wl_message("delete_id", "u", &msgTypes[0]),
    ];
    ifaces[wlDisplayIndex].name = "wl_display";
    ifaces[wlDisplayIndex].version_ = 1;
    ifaces[wlDisplayIndex].method_count = 2;
    ifaces[wlDisplayIndex].methods = wl_display_requests.ptr;
    ifaces[wlDisplayIndex].event_count = 2;
    ifaces[wlDisplayIndex].events = wl_display_events.ptr;

    auto wl_registry_requests = [
        wl_message("bind", "usun", &msgTypes[0]),
    ];
    auto wl_registry_events = [
        wl_message("global", "usu", &msgTypes[0]),
        wl_message("global_remove", "u", &msgTypes[0]),
    ];
    ifaces[wlRegistryIndex].name = "wl_registry";
    ifaces[wlRegistryIndex].version_ = 1;
    ifaces[wlRegistryIndex].method_count = 1;
    ifaces[wlRegistryIndex].methods = wl_registry_requests.ptr;
    ifaces[wlRegistryIndex].event_count = 2;
    ifaces[wlRegistryIndex].events = wl_registry_events.ptr;

    auto wl_callback_events = [
        wl_message("done", "u", &msgTypes[0]),
    ];
    ifaces[wlCallbackIndex].name = "wl_callback";
    ifaces[wlCallbackIndex].version_ = 1;
    ifaces[wlCallbackIndex].event_count = 1;
    ifaces[wlCallbackIndex].events = wl_callback_events.ptr;

    auto wl_compositor_requests = [
        wl_message("create_surface", "n", &msgTypes[10]),
        wl_message("create_region", "n", &msgTypes[11]),
    ];
    ifaces[wlCompositorIndex].name = "wl_compositor";
    ifaces[wlCompositorIndex].version_ = 6;
    ifaces[wlCompositorIndex].method_count = 2;
    ifaces[wlCompositorIndex].methods = wl_compositor_requests.ptr;

    auto wl_shm_pool_requests = [
        wl_message("create_buffer", "niiiiu", &msgTypes[12]),
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("resize", "i", &msgTypes[0]),
    ];
    ifaces[wlShmPoolIndex].name = "wl_shm_pool";
    ifaces[wlShmPoolIndex].version_ = 2;
    ifaces[wlShmPoolIndex].method_count = 3;
    ifaces[wlShmPoolIndex].methods = wl_shm_pool_requests.ptr;

    auto wl_shm_requests = [
        wl_message("create_pool", "nhi", &msgTypes[18]),
        wl_message("release", "2", &msgTypes[0]),
    ];
    auto wl_shm_events = [
        wl_message("format", "u", &msgTypes[0]),
    ];
    ifaces[wlShmIndex].name = "wl_shm";
    ifaces[wlShmIndex].version_ = 2;
    ifaces[wlShmIndex].method_count = 2;
    ifaces[wlShmIndex].methods = wl_shm_requests.ptr;
    ifaces[wlShmIndex].event_count = 1;
    ifaces[wlShmIndex].events = wl_shm_events.ptr;

    auto wl_buffer_requests = [
        wl_message("destroy", "", &msgTypes[0]),
    ];
    auto wl_buffer_events = [
        wl_message("release", "", &msgTypes[0]),
    ];
    ifaces[wlBufferIndex].name = "wl_buffer";
    ifaces[wlBufferIndex].version_ = 1;
    ifaces[wlBufferIndex].method_count = 1;
    ifaces[wlBufferIndex].methods = wl_buffer_requests.ptr;
    ifaces[wlBufferIndex].event_count = 1;
    ifaces[wlBufferIndex].events = wl_buffer_events.ptr;

    auto wl_data_offer_requests = [
        wl_message("accept", "u?s", &msgTypes[0]),
        wl_message("receive", "sh", &msgTypes[0]),
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("finish", "3", &msgTypes[0]),
        wl_message("set_actions", "3uu", &msgTypes[0]),
    ];
    auto wl_data_offer_events = [
        wl_message("offer", "s", &msgTypes[0]),
        wl_message("source_actions", "3u", &msgTypes[0]),
        wl_message("action", "3u", &msgTypes[0]),
    ];
    ifaces[wlDataOfferIndex].name = "wl_data_offer";
    ifaces[wlDataOfferIndex].version_ = 3;
    ifaces[wlDataOfferIndex].method_count = 5;
    ifaces[wlDataOfferIndex].methods = wl_data_offer_requests.ptr;
    ifaces[wlDataOfferIndex].event_count = 3;
    ifaces[wlDataOfferIndex].events = wl_data_offer_events.ptr;

    auto wl_data_source_requests = [
        wl_message("offer", "s", &msgTypes[0]),
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_actions", "3u", &msgTypes[0]),
    ];
    auto wl_data_source_events = [
        wl_message("target", "?s", &msgTypes[0]),
        wl_message("send", "sh", &msgTypes[0]),
        wl_message("cancelled", "", &msgTypes[0]),
        wl_message("dnd_drop_performed", "3", &msgTypes[0]),
        wl_message("dnd_finished", "3", &msgTypes[0]),
        wl_message("action", "3u", &msgTypes[0]),
    ];
    ifaces[wlDataSourceIndex].name = "wl_data_source";
    ifaces[wlDataSourceIndex].version_ = 3;
    ifaces[wlDataSourceIndex].method_count = 3;
    ifaces[wlDataSourceIndex].methods = wl_data_source_requests.ptr;
    ifaces[wlDataSourceIndex].event_count = 6;
    ifaces[wlDataSourceIndex].events = wl_data_source_events.ptr;

    auto wl_data_device_requests = [
        wl_message("start_drag", "?oo?ou", &msgTypes[21]),
        wl_message("set_selection", "?ou", &msgTypes[25]),
        wl_message("release", "2", &msgTypes[0]),
    ];
    auto wl_data_device_events = [
        wl_message("data_offer", "n", &msgTypes[27]),
        wl_message("enter", "uoff?o", &msgTypes[28]),
        wl_message("leave", "", &msgTypes[0]),
        wl_message("motion", "uff", &msgTypes[0]),
        wl_message("drop", "", &msgTypes[0]),
        wl_message("selection", "?o", &msgTypes[33]),
    ];
    ifaces[wlDataDeviceIndex].name = "wl_data_device";
    ifaces[wlDataDeviceIndex].version_ = 3;
    ifaces[wlDataDeviceIndex].method_count = 3;
    ifaces[wlDataDeviceIndex].methods = wl_data_device_requests.ptr;
    ifaces[wlDataDeviceIndex].event_count = 6;
    ifaces[wlDataDeviceIndex].events = wl_data_device_events.ptr;

    auto wl_data_device_manager_requests = [
        wl_message("create_data_source", "n", &msgTypes[34]),
        wl_message("get_data_device", "no", &msgTypes[35]),
    ];
    ifaces[wlDataDeviceManagerIndex].name = "wl_data_device_manager";
    ifaces[wlDataDeviceManagerIndex].version_ = 3;
    ifaces[wlDataDeviceManagerIndex].method_count = 2;
    ifaces[wlDataDeviceManagerIndex].methods = wl_data_device_manager_requests.ptr;

    auto wl_shell_requests = [
        wl_message("get_shell_surface", "no", &msgTypes[37]),
    ];
    ifaces[wlShellIndex].name = "wl_shell";
    ifaces[wlShellIndex].version_ = 1;
    ifaces[wlShellIndex].method_count = 1;
    ifaces[wlShellIndex].methods = wl_shell_requests.ptr;

    auto wl_shell_surface_requests = [
        wl_message("pong", "u", &msgTypes[0]),
        wl_message("move", "ou", &msgTypes[39]),
        wl_message("resize", "ouu", &msgTypes[41]),
        wl_message("set_toplevel", "", &msgTypes[0]),
        wl_message("set_transient", "oiiu", &msgTypes[44]),
        wl_message("set_fullscreen", "uu?o", &msgTypes[48]),
        wl_message("set_popup", "ouoiiu", &msgTypes[51]),
        wl_message("set_maximized", "?o", &msgTypes[57]),
        wl_message("set_title", "s", &msgTypes[0]),
        wl_message("set_class", "s", &msgTypes[0]),
    ];
    auto wl_shell_surface_events = [
        wl_message("ping", "u", &msgTypes[0]),
        wl_message("configure", "uii", &msgTypes[0]),
        wl_message("popup_done", "", &msgTypes[0]),
    ];
    ifaces[wlShellSurfaceIndex].name = "wl_shell_surface";
    ifaces[wlShellSurfaceIndex].version_ = 1;
    ifaces[wlShellSurfaceIndex].method_count = 10;
    ifaces[wlShellSurfaceIndex].methods = wl_shell_surface_requests.ptr;
    ifaces[wlShellSurfaceIndex].event_count = 3;
    ifaces[wlShellSurfaceIndex].events = wl_shell_surface_events.ptr;

    auto wl_surface_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("attach", "?oii", &msgTypes[58]),
        wl_message("damage", "iiii", &msgTypes[0]),
        wl_message("frame", "n", &msgTypes[61]),
        wl_message("set_opaque_region", "?o", &msgTypes[62]),
        wl_message("set_input_region", "?o", &msgTypes[63]),
        wl_message("commit", "", &msgTypes[0]),
        wl_message("set_buffer_transform", "2i", &msgTypes[0]),
        wl_message("set_buffer_scale", "3i", &msgTypes[0]),
        wl_message("damage_buffer", "4iiii", &msgTypes[0]),
        wl_message("offset", "5ii", &msgTypes[0]),
    ];
    auto wl_surface_events = [
        wl_message("enter", "o", &msgTypes[64]),
        wl_message("leave", "o", &msgTypes[65]),
        wl_message("preferred_buffer_scale", "6i", &msgTypes[0]),
        wl_message("preferred_buffer_transform", "6u", &msgTypes[0]),
    ];
    ifaces[wlSurfaceIndex].name = "wl_surface";
    ifaces[wlSurfaceIndex].version_ = 6;
    ifaces[wlSurfaceIndex].method_count = 11;
    ifaces[wlSurfaceIndex].methods = wl_surface_requests.ptr;
    ifaces[wlSurfaceIndex].event_count = 4;
    ifaces[wlSurfaceIndex].events = wl_surface_events.ptr;

    auto wl_seat_requests = [
        wl_message("get_pointer", "n", &msgTypes[66]),
        wl_message("get_keyboard", "n", &msgTypes[67]),
        wl_message("get_touch", "n", &msgTypes[68]),
        wl_message("release", "5", &msgTypes[0]),
    ];
    auto wl_seat_events = [
        wl_message("capabilities", "u", &msgTypes[0]),
        wl_message("name", "2s", &msgTypes[0]),
    ];
    ifaces[wlSeatIndex].name = "wl_seat";
    ifaces[wlSeatIndex].version_ = 9;
    ifaces[wlSeatIndex].method_count = 4;
    ifaces[wlSeatIndex].methods = wl_seat_requests.ptr;
    ifaces[wlSeatIndex].event_count = 2;
    ifaces[wlSeatIndex].events = wl_seat_events.ptr;

    auto wl_pointer_requests = [
        wl_message("set_cursor", "u?oii", &msgTypes[69]),
        wl_message("release", "3", &msgTypes[0]),
    ];
    auto wl_pointer_events = [
        wl_message("enter", "uoff", &msgTypes[73]),
        wl_message("leave", "uo", &msgTypes[77]),
        wl_message("motion", "uff", &msgTypes[0]),
        wl_message("button", "uuuu", &msgTypes[0]),
        wl_message("axis", "uuf", &msgTypes[0]),
        wl_message("frame", "5", &msgTypes[0]),
        wl_message("axis_source", "5u", &msgTypes[0]),
        wl_message("axis_stop", "5uu", &msgTypes[0]),
        wl_message("axis_discrete", "5ui", &msgTypes[0]),
        wl_message("axis_value120", "8ui", &msgTypes[0]),
        wl_message("axis_relative_direction", "9uu", &msgTypes[0]),
    ];
    ifaces[wlPointerIndex].name = "wl_pointer";
    ifaces[wlPointerIndex].version_ = 9;
    ifaces[wlPointerIndex].method_count = 2;
    ifaces[wlPointerIndex].methods = wl_pointer_requests.ptr;
    ifaces[wlPointerIndex].event_count = 11;
    ifaces[wlPointerIndex].events = wl_pointer_events.ptr;

    auto wl_keyboard_requests = [
        wl_message("release", "3", &msgTypes[0]),
    ];
    auto wl_keyboard_events = [
        wl_message("keymap", "uhu", &msgTypes[0]),
        wl_message("enter", "uoa", &msgTypes[79]),
        wl_message("leave", "uo", &msgTypes[82]),
        wl_message("key", "uuuu", &msgTypes[0]),
        wl_message("modifiers", "uuuuu", &msgTypes[0]),
        wl_message("repeat_info", "4ii", &msgTypes[0]),
    ];
    ifaces[wlKeyboardIndex].name = "wl_keyboard";
    ifaces[wlKeyboardIndex].version_ = 9;
    ifaces[wlKeyboardIndex].method_count = 1;
    ifaces[wlKeyboardIndex].methods = wl_keyboard_requests.ptr;
    ifaces[wlKeyboardIndex].event_count = 6;
    ifaces[wlKeyboardIndex].events = wl_keyboard_events.ptr;

    auto wl_touch_requests = [
        wl_message("release", "3", &msgTypes[0]),
    ];
    auto wl_touch_events = [
        wl_message("down", "uuoiff", &msgTypes[84]),
        wl_message("up", "uui", &msgTypes[0]),
        wl_message("motion", "uiff", &msgTypes[0]),
        wl_message("frame", "", &msgTypes[0]),
        wl_message("cancel", "", &msgTypes[0]),
        wl_message("shape", "6iff", &msgTypes[0]),
        wl_message("orientation", "6if", &msgTypes[0]),
    ];
    ifaces[wlTouchIndex].name = "wl_touch";
    ifaces[wlTouchIndex].version_ = 9;
    ifaces[wlTouchIndex].method_count = 1;
    ifaces[wlTouchIndex].methods = wl_touch_requests.ptr;
    ifaces[wlTouchIndex].event_count = 7;
    ifaces[wlTouchIndex].events = wl_touch_events.ptr;

    auto wl_output_requests = [
        wl_message("release", "3", &msgTypes[0]),
    ];
    auto wl_output_events = [
        wl_message("geometry", "iiiiissi", &msgTypes[0]),
        wl_message("mode", "uiii", &msgTypes[0]),
        wl_message("done", "2", &msgTypes[0]),
        wl_message("scale", "2i", &msgTypes[0]),
        wl_message("name", "4s", &msgTypes[0]),
        wl_message("description", "4s", &msgTypes[0]),
    ];
    ifaces[wlOutputIndex].name = "wl_output";
    ifaces[wlOutputIndex].version_ = 4;
    ifaces[wlOutputIndex].method_count = 1;
    ifaces[wlOutputIndex].methods = wl_output_requests.ptr;
    ifaces[wlOutputIndex].event_count = 6;
    ifaces[wlOutputIndex].events = wl_output_events.ptr;

    auto wl_region_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("add", "iiii", &msgTypes[0]),
        wl_message("subtract", "iiii", &msgTypes[0]),
    ];
    ifaces[wlRegionIndex].name = "wl_region";
    ifaces[wlRegionIndex].version_ = 1;
    ifaces[wlRegionIndex].method_count = 3;
    ifaces[wlRegionIndex].methods = wl_region_requests.ptr;

    auto wl_subcompositor_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("get_subsurface", "noo", &msgTypes[90]),
    ];
    ifaces[wlSubcompositorIndex].name = "wl_subcompositor";
    ifaces[wlSubcompositorIndex].version_ = 1;
    ifaces[wlSubcompositorIndex].method_count = 2;
    ifaces[wlSubcompositorIndex].methods = wl_subcompositor_requests.ptr;

    auto wl_subsurface_requests = [
        wl_message("destroy", "", &msgTypes[0]),
        wl_message("set_position", "ii", &msgTypes[0]),
        wl_message("place_above", "o", &msgTypes[93]),
        wl_message("place_below", "o", &msgTypes[94]),
        wl_message("set_sync", "", &msgTypes[0]),
        wl_message("set_desync", "", &msgTypes[0]),
    ];
    ifaces[wlSubsurfaceIndex].name = "wl_subsurface";
    ifaces[wlSubsurfaceIndex].version_ = 1;
    ifaces[wlSubsurfaceIndex].method_count = 6;
    ifaces[wlSubsurfaceIndex].methods = wl_subsurface_requests.ptr;

    import std.exception : assumeUnique;
    wl_ifaces = assumeUnique(ifaces);

    wlDisplayIface = new immutable WlDisplayIface( &wl_ifaces[wlDisplayIndex] );
    wlRegistryIface = new immutable WlRegistryIface( &wl_ifaces[wlRegistryIndex] );
    wlCallbackIface = new immutable WlCallbackIface( &wl_ifaces[wlCallbackIndex] );
    wlCompositorIface = new immutable WlCompositorIface( &wl_ifaces[wlCompositorIndex] );
    wlShmPoolIface = new immutable WlShmPoolIface( &wl_ifaces[wlShmPoolIndex] );
    wlShmIface = new immutable WlShmIface( &wl_ifaces[wlShmIndex] );
    wlBufferIface = new immutable WlBufferIface( &wl_ifaces[wlBufferIndex] );
    wlDataOfferIface = new immutable WlDataOfferIface( &wl_ifaces[wlDataOfferIndex] );
    wlDataSourceIface = new immutable WlDataSourceIface( &wl_ifaces[wlDataSourceIndex] );
    wlDataDeviceIface = new immutable WlDataDeviceIface( &wl_ifaces[wlDataDeviceIndex] );
    wlDataDeviceManagerIface = new immutable WlDataDeviceManagerIface( &wl_ifaces[wlDataDeviceManagerIndex] );
    wlShellIface = new immutable WlShellIface( &wl_ifaces[wlShellIndex] );
    wlShellSurfaceIface = new immutable WlShellSurfaceIface( &wl_ifaces[wlShellSurfaceIndex] );
    wlSurfaceIface = new immutable WlSurfaceIface( &wl_ifaces[wlSurfaceIndex] );
    wlSeatIface = new immutable WlSeatIface( &wl_ifaces[wlSeatIndex] );
    wlPointerIface = new immutable WlPointerIface( &wl_ifaces[wlPointerIndex] );
    wlKeyboardIface = new immutable WlKeyboardIface( &wl_ifaces[wlKeyboardIndex] );
    wlTouchIface = new immutable WlTouchIface( &wl_ifaces[wlTouchIndex] );
    wlOutputIface = new immutable WlOutputIface( &wl_ifaces[wlOutputIndex] );
    wlRegionIface = new immutable WlRegionIface( &wl_ifaces[wlRegionIndex] );
    wlSubcompositorIface = new immutable WlSubcompositorIface( &wl_ifaces[wlSubcompositorIndex] );
    wlSubsurfaceIface = new immutable WlSubsurfaceIface( &wl_ifaces[wlSubsurfaceIndex] );
}

extern(C) nothrow
{

    struct wl_registry_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint name,
                      const(char)* iface,
                      uint version_) global;
        void function(void* data,
                      wl_proxy* proxy,
                      uint name) global_remove;
    }

    __gshared wl_d_wl_registry_listener = wl_registry_listener (&wl_d_on_wl_registry_global,
                                                                &wl_d_on_wl_registry_global_remove);

    void wl_d_on_wl_registry_global(void* data,
                                    wl_proxy* proxy,
                                    uint name,
                                    const(char)* iface,
                                    uint version_)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlRegistry)_p;
            assert(_i, "listener stub proxy is not WlRegistry");
            if (_i._onGlobal)
            {
                _i._onGlobal(_i, name, fromStringz(iface).idup, version_);
            }
        });
    }

    void wl_d_on_wl_registry_global_remove(void* data,
                                           wl_proxy* proxy,
                                           uint name)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlRegistry)_p;
            assert(_i, "listener stub proxy is not WlRegistry");
            if (_i._onGlobalRemove)
            {
                _i._onGlobalRemove(_i, name);
            }
        });
    }

    struct wl_callback_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint callbackData) done;
    }

    __gshared wl_d_wl_callback_listener = wl_callback_listener (&wl_d_on_wl_callback_done);

    void wl_d_on_wl_callback_done(void* data,
                                  wl_proxy* proxy,
                                  uint callbackData)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlCallback)_p;
            assert(_i, "listener stub proxy is not WlCallback");
            if (_i._onDone)
            {
                _i._onDone(_i, callbackData);
            }
        });
    }



    struct wl_shm_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint format) format;
    }

    __gshared wl_d_wl_shm_listener = wl_shm_listener (&wl_d_on_wl_shm_format);

    void wl_d_on_wl_shm_format(void* data,
                               wl_proxy* proxy,
                               uint format)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlShm)_p;
            assert(_i, "listener stub proxy is not WlShm");
            if (_i._onFormat)
            {
                _i._onFormat(_i, cast(WlShm.Format)format);
            }
        });
    }

    struct wl_buffer_listener
    {
        void function(void* data,
                      wl_proxy* proxy) release;
    }

    __gshared wl_d_wl_buffer_listener = wl_buffer_listener (&wl_d_on_wl_buffer_release);

    void wl_d_on_wl_buffer_release(void* data,
                                   wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlBuffer)_p;
            assert(_i, "listener stub proxy is not WlBuffer");
            if (_i._onRelease)
            {
                _i._onRelease(_i);
            }
        });
    }

    struct wl_data_offer_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* mimeType) offer;
        void function(void* data,
                      wl_proxy* proxy,
                      uint sourceActions) source_actions;
        void function(void* data,
                      wl_proxy* proxy,
                      uint dndAction) action;
    }

    __gshared wl_d_wl_data_offer_listener = wl_data_offer_listener (&wl_d_on_wl_data_offer_offer,
                                                                    &wl_d_on_wl_data_offer_source_actions,
                                                                    &wl_d_on_wl_data_offer_action);

    void wl_d_on_wl_data_offer_offer(void* data,
                                     wl_proxy* proxy,
                                     const(char)* mimeType)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataOffer)_p;
            assert(_i, "listener stub proxy is not WlDataOffer");
            if (_i._onOffer)
            {
                _i._onOffer(_i, fromStringz(mimeType).idup);
            }
        });
    }

    void wl_d_on_wl_data_offer_source_actions(void* data,
                                              wl_proxy* proxy,
                                              uint sourceActions)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataOffer)_p;
            assert(_i, "listener stub proxy is not WlDataOffer");
            if (_i._onSourceActions)
            {
                _i._onSourceActions(_i, cast(WlDataDeviceManager.DndAction)sourceActions);
            }
        });
    }

    void wl_d_on_wl_data_offer_action(void* data,
                                      wl_proxy* proxy,
                                      uint dndAction)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataOffer)_p;
            assert(_i, "listener stub proxy is not WlDataOffer");
            if (_i._onAction)
            {
                _i._onAction(_i, cast(WlDataDeviceManager.DndAction)dndAction);
            }
        });
    }

    struct wl_data_source_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* mimeType) target;
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* mimeType,
                      int fd) send;
        void function(void* data,
                      wl_proxy* proxy) cancelled;
        void function(void* data,
                      wl_proxy* proxy) dnd_drop_performed;
        void function(void* data,
                      wl_proxy* proxy) dnd_finished;
        void function(void* data,
                      wl_proxy* proxy,
                      uint dndAction) action;
    }

    __gshared wl_d_wl_data_source_listener = wl_data_source_listener (&wl_d_on_wl_data_source_target,
                                                                      &wl_d_on_wl_data_source_send,
                                                                      &wl_d_on_wl_data_source_cancelled,
                                                                      &wl_d_on_wl_data_source_dnd_drop_performed,
                                                                      &wl_d_on_wl_data_source_dnd_finished,
                                                                      &wl_d_on_wl_data_source_action);

    void wl_d_on_wl_data_source_target(void* data,
                                       wl_proxy* proxy,
                                       const(char)* mimeType)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onTarget)
            {
                _i._onTarget(_i, fromStringz(mimeType).idup);
            }
        });
    }

    void wl_d_on_wl_data_source_send(void* data,
                                     wl_proxy* proxy,
                                     const(char)* mimeType,
                                     int fd)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onSend)
            {
                _i._onSend(_i, fromStringz(mimeType).idup, fd);
            }
        });
    }

    void wl_d_on_wl_data_source_cancelled(void* data,
                                          wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onCancelled)
            {
                _i._onCancelled(_i);
            }
        });
    }

    void wl_d_on_wl_data_source_dnd_drop_performed(void* data,
                                                   wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onDndDropPerformed)
            {
                _i._onDndDropPerformed(_i);
            }
        });
    }

    void wl_d_on_wl_data_source_dnd_finished(void* data,
                                             wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onDndFinished)
            {
                _i._onDndFinished(_i);
            }
        });
    }

    void wl_d_on_wl_data_source_action(void* data,
                                       wl_proxy* proxy,
                                       uint dndAction)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataSource)_p;
            assert(_i, "listener stub proxy is not WlDataSource");
            if (_i._onAction)
            {
                _i._onAction(_i, cast(WlDataDeviceManager.DndAction)dndAction);
            }
        });
    }

    struct wl_data_device_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      wl_proxy* id) data_offer;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      wl_proxy* surface,
                      wl_fixed_t x,
                      wl_fixed_t y,
                      wl_proxy* id) enter;
        void function(void* data,
                      wl_proxy* proxy) leave;
        void function(void* data,
                      wl_proxy* proxy,
                      uint time,
                      wl_fixed_t x,
                      wl_fixed_t y) motion;
        void function(void* data,
                      wl_proxy* proxy) drop;
        void function(void* data,
                      wl_proxy* proxy,
                      wl_proxy* id) selection;
    }

    __gshared wl_d_wl_data_device_listener = wl_data_device_listener (&wl_d_on_wl_data_device_data_offer,
                                                                      &wl_d_on_wl_data_device_enter,
                                                                      &wl_d_on_wl_data_device_leave,
                                                                      &wl_d_on_wl_data_device_motion,
                                                                      &wl_d_on_wl_data_device_drop,
                                                                      &wl_d_on_wl_data_device_selection);

    void wl_d_on_wl_data_device_data_offer(void* data,
                                           wl_proxy* proxy,
                                           wl_proxy* id)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onDataOffer)
            {
                _i._onDataOffer(_i, new WlDataOffer(id));
            }
        });
    }

    void wl_d_on_wl_data_device_enter(void* data,
                                      wl_proxy* proxy,
                                      uint serial,
                                      wl_proxy* surface,
                                      wl_fixed_t x,
                                      wl_fixed_t y,
                                      wl_proxy* id)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onEnter)
            {
                _i._onEnter(_i, serial, cast(WlSurface)WlProxy.get(surface), WlFixed(x), WlFixed(y), cast(WlDataOffer)WlProxy.get(id));
            }
        });
    }

    void wl_d_on_wl_data_device_leave(void* data,
                                      wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onLeave)
            {
                _i._onLeave(_i);
            }
        });
    }

    void wl_d_on_wl_data_device_motion(void* data,
                                       wl_proxy* proxy,
                                       uint time,
                                       wl_fixed_t x,
                                       wl_fixed_t y)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onMotion)
            {
                _i._onMotion(_i, time, WlFixed(x), WlFixed(y));
            }
        });
    }

    void wl_d_on_wl_data_device_drop(void* data,
                                     wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onDrop)
            {
                _i._onDrop(_i);
            }
        });
    }

    void wl_d_on_wl_data_device_selection(void* data,
                                          wl_proxy* proxy,
                                          wl_proxy* id)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlDataDevice)_p;
            assert(_i, "listener stub proxy is not WlDataDevice");
            if (_i._onSelection)
            {
                _i._onSelection(_i, cast(WlDataOffer)WlProxy.get(id));
            }
        });
    }



    struct wl_shell_surface_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial) ping;
        void function(void* data,
                      wl_proxy* proxy,
                      uint edges,
                      int width,
                      int height) configure;
        void function(void* data,
                      wl_proxy* proxy) popup_done;
    }

    __gshared wl_d_wl_shell_surface_listener = wl_shell_surface_listener (&wl_d_on_wl_shell_surface_ping,
                                                                          &wl_d_on_wl_shell_surface_configure,
                                                                          &wl_d_on_wl_shell_surface_popup_done);

    void wl_d_on_wl_shell_surface_ping(void* data,
                                       wl_proxy* proxy,
                                       uint serial)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlShellSurface)_p;
            assert(_i, "listener stub proxy is not WlShellSurface");
            if (_i._onPing)
            {
                _i._onPing(_i, serial);
            }
        });
    }

    void wl_d_on_wl_shell_surface_configure(void* data,
                                            wl_proxy* proxy,
                                            uint edges,
                                            int width,
                                            int height)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlShellSurface)_p;
            assert(_i, "listener stub proxy is not WlShellSurface");
            if (_i._onConfigure)
            {
                _i._onConfigure(_i, cast(WlShellSurface.Resize)edges, width, height);
            }
        });
    }

    void wl_d_on_wl_shell_surface_popup_done(void* data,
                                             wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlShellSurface)_p;
            assert(_i, "listener stub proxy is not WlShellSurface");
            if (_i._onPopupDone)
            {
                _i._onPopupDone(_i);
            }
        });
    }

    struct wl_surface_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      wl_proxy* output) enter;
        void function(void* data,
                      wl_proxy* proxy,
                      wl_proxy* output) leave;
        void function(void* data,
                      wl_proxy* proxy,
                      int factor) preferred_buffer_scale;
        void function(void* data,
                      wl_proxy* proxy,
                      uint transform) preferred_buffer_transform;
    }

    __gshared wl_d_wl_surface_listener = wl_surface_listener (&wl_d_on_wl_surface_enter,
                                                              &wl_d_on_wl_surface_leave,
                                                              &wl_d_on_wl_surface_preferred_buffer_scale,
                                                              &wl_d_on_wl_surface_preferred_buffer_transform);

    void wl_d_on_wl_surface_enter(void* data,
                                  wl_proxy* proxy,
                                  wl_proxy* output)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSurface)_p;
            assert(_i, "listener stub proxy is not WlSurface");
            if (_i._onEnter)
            {
                _i._onEnter(_i, cast(WlOutput)WlProxy.get(output));
            }
        });
    }

    void wl_d_on_wl_surface_leave(void* data,
                                  wl_proxy* proxy,
                                  wl_proxy* output)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSurface)_p;
            assert(_i, "listener stub proxy is not WlSurface");
            if (_i._onLeave)
            {
                _i._onLeave(_i, cast(WlOutput)WlProxy.get(output));
            }
        });
    }

    void wl_d_on_wl_surface_preferred_buffer_scale(void* data,
                                                   wl_proxy* proxy,
                                                   int factor)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSurface)_p;
            assert(_i, "listener stub proxy is not WlSurface");
            if (_i._onPreferredBufferScale)
            {
                _i._onPreferredBufferScale(_i, factor);
            }
        });
    }

    void wl_d_on_wl_surface_preferred_buffer_transform(void* data,
                                                       wl_proxy* proxy,
                                                       uint transform)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSurface)_p;
            assert(_i, "listener stub proxy is not WlSurface");
            if (_i._onPreferredBufferTransform)
            {
                _i._onPreferredBufferTransform(_i, cast(WlOutput.Transform)transform);
            }
        });
    }

    struct wl_seat_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint capabilities) capabilities;
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* name) name;
    }

    __gshared wl_d_wl_seat_listener = wl_seat_listener (&wl_d_on_wl_seat_capabilities,
                                                        &wl_d_on_wl_seat_name);

    void wl_d_on_wl_seat_capabilities(void* data,
                                      wl_proxy* proxy,
                                      uint capabilities)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSeat)_p;
            assert(_i, "listener stub proxy is not WlSeat");
            if (_i._onCapabilities)
            {
                _i._onCapabilities(_i, cast(WlSeat.Capability)capabilities);
            }
        });
    }

    void wl_d_on_wl_seat_name(void* data,
                              wl_proxy* proxy,
                              const(char)* name)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlSeat)_p;
            assert(_i, "listener stub proxy is not WlSeat");
            if (_i._onName)
            {
                _i._onName(_i, fromStringz(name).idup);
            }
        });
    }

    struct wl_pointer_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      wl_proxy* surface,
                      wl_fixed_t surfaceX,
                      wl_fixed_t surfaceY) enter;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      wl_proxy* surface) leave;
        void function(void* data,
                      wl_proxy* proxy,
                      uint time,
                      wl_fixed_t surfaceX,
                      wl_fixed_t surfaceY) motion;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      uint time,
                      uint button,
                      uint state) button;
        void function(void* data,
                      wl_proxy* proxy,
                      uint time,
                      uint axis,
                      wl_fixed_t value) axis;
        void function(void* data,
                      wl_proxy* proxy) frame;
        void function(void* data,
                      wl_proxy* proxy,
                      uint axisSource) axis_source;
        void function(void* data,
                      wl_proxy* proxy,
                      uint time,
                      uint axis) axis_stop;
        void function(void* data,
                      wl_proxy* proxy,
                      uint axis,
                      int discrete) axis_discrete;
        void function(void* data,
                      wl_proxy* proxy,
                      uint axis,
                      int value120) axis_value120;
        void function(void* data,
                      wl_proxy* proxy,
                      uint axis,
                      uint direction) axis_relative_direction;
    }

    __gshared wl_d_wl_pointer_listener = wl_pointer_listener (&wl_d_on_wl_pointer_enter,
                                                              &wl_d_on_wl_pointer_leave,
                                                              &wl_d_on_wl_pointer_motion,
                                                              &wl_d_on_wl_pointer_button,
                                                              &wl_d_on_wl_pointer_axis,
                                                              &wl_d_on_wl_pointer_frame,
                                                              &wl_d_on_wl_pointer_axis_source,
                                                              &wl_d_on_wl_pointer_axis_stop,
                                                              &wl_d_on_wl_pointer_axis_discrete,
                                                              &wl_d_on_wl_pointer_axis_value120,
                                                              &wl_d_on_wl_pointer_axis_relative_direction);

    void wl_d_on_wl_pointer_enter(void* data,
                                  wl_proxy* proxy,
                                  uint serial,
                                  wl_proxy* surface,
                                  wl_fixed_t surfaceX,
                                  wl_fixed_t surfaceY)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onEnter)
            {
                _i._onEnter(_i, serial, cast(WlSurface)WlProxy.get(surface), WlFixed(surfaceX), WlFixed(surfaceY));
            }
        });
    }

    void wl_d_on_wl_pointer_leave(void* data,
                                  wl_proxy* proxy,
                                  uint serial,
                                  wl_proxy* surface)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onLeave)
            {
                _i._onLeave(_i, serial, cast(WlSurface)WlProxy.get(surface));
            }
        });
    }

    void wl_d_on_wl_pointer_motion(void* data,
                                   wl_proxy* proxy,
                                   uint time,
                                   wl_fixed_t surfaceX,
                                   wl_fixed_t surfaceY)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onMotion)
            {
                _i._onMotion(_i, time, WlFixed(surfaceX), WlFixed(surfaceY));
            }
        });
    }

    void wl_d_on_wl_pointer_button(void* data,
                                   wl_proxy* proxy,
                                   uint serial,
                                   uint time,
                                   uint button,
                                   uint state)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onButton)
            {
                _i._onButton(_i, serial, time, button, cast(WlPointer.ButtonState)state);
            }
        });
    }

    void wl_d_on_wl_pointer_axis(void* data,
                                 wl_proxy* proxy,
                                 uint time,
                                 uint axis,
                                 wl_fixed_t value)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxis)
            {
                _i._onAxis(_i, time, cast(WlPointer.Axis)axis, WlFixed(value));
            }
        });
    }

    void wl_d_on_wl_pointer_frame(void* data,
                                  wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onFrame)
            {
                _i._onFrame(_i);
            }
        });
    }

    void wl_d_on_wl_pointer_axis_source(void* data,
                                        wl_proxy* proxy,
                                        uint axisSource)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxisSource)
            {
                _i._onAxisSource(_i, cast(WlPointer.AxisSource)axisSource);
            }
        });
    }

    void wl_d_on_wl_pointer_axis_stop(void* data,
                                      wl_proxy* proxy,
                                      uint time,
                                      uint axis)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxisStop)
            {
                _i._onAxisStop(_i, time, cast(WlPointer.Axis)axis);
            }
        });
    }

    void wl_d_on_wl_pointer_axis_discrete(void* data,
                                          wl_proxy* proxy,
                                          uint axis,
                                          int discrete)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxisDiscrete)
            {
                _i._onAxisDiscrete(_i, cast(WlPointer.Axis)axis, discrete);
            }
        });
    }

    void wl_d_on_wl_pointer_axis_value120(void* data,
                                          wl_proxy* proxy,
                                          uint axis,
                                          int value120)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxisValue120)
            {
                _i._onAxisValue120(_i, cast(WlPointer.Axis)axis, value120);
            }
        });
    }

    void wl_d_on_wl_pointer_axis_relative_direction(void* data,
                                                    wl_proxy* proxy,
                                                    uint axis,
                                                    uint direction)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlPointer)_p;
            assert(_i, "listener stub proxy is not WlPointer");
            if (_i._onAxisRelativeDirection)
            {
                _i._onAxisRelativeDirection(_i, cast(WlPointer.Axis)axis, cast(WlPointer.AxisRelativeDirection)direction);
            }
        });
    }

    struct wl_keyboard_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint format,
                      int fd,
                      uint size) keymap;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      wl_proxy* surface,
                      wl_array* keys) enter;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      wl_proxy* surface) leave;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      uint time,
                      uint key,
                      uint state) key;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      uint modsDepressed,
                      uint modsLatched,
                      uint modsLocked,
                      uint group) modifiers;
        void function(void* data,
                      wl_proxy* proxy,
                      int rate,
                      int delay) repeat_info;
    }

    __gshared wl_d_wl_keyboard_listener = wl_keyboard_listener (&wl_d_on_wl_keyboard_keymap,
                                                                &wl_d_on_wl_keyboard_enter,
                                                                &wl_d_on_wl_keyboard_leave,
                                                                &wl_d_on_wl_keyboard_key,
                                                                &wl_d_on_wl_keyboard_modifiers,
                                                                &wl_d_on_wl_keyboard_repeat_info);

    void wl_d_on_wl_keyboard_keymap(void* data,
                                    wl_proxy* proxy,
                                    uint format,
                                    int fd,
                                    uint size)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onKeymap)
            {
                _i._onKeymap(_i, cast(WlKeyboard.KeymapFormat)format, fd, size);
            }
        });
    }

    void wl_d_on_wl_keyboard_enter(void* data,
                                   wl_proxy* proxy,
                                   uint serial,
                                   wl_proxy* surface,
                                   wl_array* keys)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onEnter)
            {
                _i._onEnter(_i, serial, cast(WlSurface)WlProxy.get(surface), keys);
            }
        });
    }

    void wl_d_on_wl_keyboard_leave(void* data,
                                   wl_proxy* proxy,
                                   uint serial,
                                   wl_proxy* surface)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onLeave)
            {
                _i._onLeave(_i, serial, cast(WlSurface)WlProxy.get(surface));
            }
        });
    }

    void wl_d_on_wl_keyboard_key(void* data,
                                 wl_proxy* proxy,
                                 uint serial,
                                 uint time,
                                 uint key,
                                 uint state)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onKey)
            {
                _i._onKey(_i, serial, time, key, cast(WlKeyboard.KeyState)state);
            }
        });
    }

    void wl_d_on_wl_keyboard_modifiers(void* data,
                                       wl_proxy* proxy,
                                       uint serial,
                                       uint modsDepressed,
                                       uint modsLatched,
                                       uint modsLocked,
                                       uint group)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onModifiers)
            {
                _i._onModifiers(_i, serial, modsDepressed, modsLatched, modsLocked, group);
            }
        });
    }

    void wl_d_on_wl_keyboard_repeat_info(void* data,
                                         wl_proxy* proxy,
                                         int rate,
                                         int delay)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlKeyboard)_p;
            assert(_i, "listener stub proxy is not WlKeyboard");
            if (_i._onRepeatInfo)
            {
                _i._onRepeatInfo(_i, rate, delay);
            }
        });
    }

    struct wl_touch_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      uint time,
                      wl_proxy* surface,
                      int id,
                      wl_fixed_t x,
                      wl_fixed_t y) down;
        void function(void* data,
                      wl_proxy* proxy,
                      uint serial,
                      uint time,
                      int id) up;
        void function(void* data,
                      wl_proxy* proxy,
                      uint time,
                      int id,
                      wl_fixed_t x,
                      wl_fixed_t y) motion;
        void function(void* data,
                      wl_proxy* proxy) frame;
        void function(void* data,
                      wl_proxy* proxy) cancel;
        void function(void* data,
                      wl_proxy* proxy,
                      int id,
                      wl_fixed_t major,
                      wl_fixed_t minor) shape;
        void function(void* data,
                      wl_proxy* proxy,
                      int id,
                      wl_fixed_t orientation) orientation;
    }

    __gshared wl_d_wl_touch_listener = wl_touch_listener (&wl_d_on_wl_touch_down,
                                                          &wl_d_on_wl_touch_up,
                                                          &wl_d_on_wl_touch_motion,
                                                          &wl_d_on_wl_touch_frame,
                                                          &wl_d_on_wl_touch_cancel,
                                                          &wl_d_on_wl_touch_shape,
                                                          &wl_d_on_wl_touch_orientation);

    void wl_d_on_wl_touch_down(void* data,
                               wl_proxy* proxy,
                               uint serial,
                               uint time,
                               wl_proxy* surface,
                               int id,
                               wl_fixed_t x,
                               wl_fixed_t y)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onDown)
            {
                _i._onDown(_i, serial, time, cast(WlSurface)WlProxy.get(surface), id, WlFixed(x), WlFixed(y));
            }
        });
    }

    void wl_d_on_wl_touch_up(void* data,
                             wl_proxy* proxy,
                             uint serial,
                             uint time,
                             int id)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onUp)
            {
                _i._onUp(_i, serial, time, id);
            }
        });
    }

    void wl_d_on_wl_touch_motion(void* data,
                                 wl_proxy* proxy,
                                 uint time,
                                 int id,
                                 wl_fixed_t x,
                                 wl_fixed_t y)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onMotion)
            {
                _i._onMotion(_i, time, id, WlFixed(x), WlFixed(y));
            }
        });
    }

    void wl_d_on_wl_touch_frame(void* data,
                                wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onFrame)
            {
                _i._onFrame(_i);
            }
        });
    }

    void wl_d_on_wl_touch_cancel(void* data,
                                 wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onCancel)
            {
                _i._onCancel(_i);
            }
        });
    }

    void wl_d_on_wl_touch_shape(void* data,
                                wl_proxy* proxy,
                                int id,
                                wl_fixed_t major,
                                wl_fixed_t minor)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onShape)
            {
                _i._onShape(_i, id, WlFixed(major), WlFixed(minor));
            }
        });
    }

    void wl_d_on_wl_touch_orientation(void* data,
                                      wl_proxy* proxy,
                                      int id,
                                      wl_fixed_t orientation)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlTouch)_p;
            assert(_i, "listener stub proxy is not WlTouch");
            if (_i._onOrientation)
            {
                _i._onOrientation(_i, id, WlFixed(orientation));
            }
        });
    }

    struct wl_output_listener
    {
        void function(void* data,
                      wl_proxy* proxy,
                      int x,
                      int y,
                      int physicalWidth,
                      int physicalHeight,
                      int subpixel,
                      const(char)* make,
                      const(char)* model,
                      int transform) geometry;
        void function(void* data,
                      wl_proxy* proxy,
                      uint flags,
                      int width,
                      int height,
                      int refresh) mode;
        void function(void* data,
                      wl_proxy* proxy) done;
        void function(void* data,
                      wl_proxy* proxy,
                      int factor) scale;
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* name) name;
        void function(void* data,
                      wl_proxy* proxy,
                      const(char)* description) description;
    }

    __gshared wl_d_wl_output_listener = wl_output_listener (&wl_d_on_wl_output_geometry,
                                                            &wl_d_on_wl_output_mode,
                                                            &wl_d_on_wl_output_done,
                                                            &wl_d_on_wl_output_scale,
                                                            &wl_d_on_wl_output_name,
                                                            &wl_d_on_wl_output_description);

    void wl_d_on_wl_output_geometry(void* data,
                                    wl_proxy* proxy,
                                    int x,
                                    int y,
                                    int physicalWidth,
                                    int physicalHeight,
                                    int subpixel,
                                    const(char)* make,
                                    const(char)* model,
                                    int transform)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onGeometry)
            {
                _i._onGeometry(_i, x, y, physicalWidth, physicalHeight, subpixel, fromStringz(make).idup, fromStringz(model).idup, transform);
            }
        });
    }

    void wl_d_on_wl_output_mode(void* data,
                                wl_proxy* proxy,
                                uint flags,
                                int width,
                                int height,
                                int refresh)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onMode)
            {
                _i._onMode(_i, cast(WlOutput.Mode)flags, width, height, refresh);
            }
        });
    }

    void wl_d_on_wl_output_done(void* data,
                                wl_proxy* proxy)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onDone)
            {
                _i._onDone(_i);
            }
        });
    }

    void wl_d_on_wl_output_scale(void* data,
                                 wl_proxy* proxy,
                                 int factor)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onScale)
            {
                _i._onScale(_i, factor);
            }
        });
    }

    void wl_d_on_wl_output_name(void* data,
                                wl_proxy* proxy,
                                const(char)* name)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onName)
            {
                _i._onName(_i, fromStringz(name).idup);
            }
        });
    }

    void wl_d_on_wl_output_description(void* data,
                                       wl_proxy* proxy,
                                       const(char)* description)
    {
        nothrowFnWrapper!({
            auto _p = data;
            assert(_p, "listener stub without the right userdata");
            auto _i = cast(WlOutput)_p;
            assert(_i, "listener stub proxy is not WlOutput");
            if (_i._onDescription)
            {
                _i._onDescription(_i, fromStringz(description).idup);
            }
        });
    }



}
