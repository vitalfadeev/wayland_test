import std.stdio;
import core.sys.posix.sys.mman : mmap,munmap,PROT_READ,MAP_SHARED,MAP_FAILED;
import core.sys.posix.sys.stat : fstat,stat_t;
import core.sys.posix.fcntl    : open,O_RDWR;
import core.stdc.stdlib        : EXIT_SUCCESS,EXIT_FAILURE;
import core.stdc.stdlib        : free;
import std.conv                : to;
import wayland_struct;
//import wayland_struct.protocol; // generated by wl;
//import wayland_struct.protocol2; // generated by wl;
//import wayland_struct.dy_loader;


static const uint WIDTH             = 320;
static const uint HEIGHT            = 200;
static const uint CURSOR_WIDTH      = 100;
static const uint CURSOR_HEIGHT     = 59;
static const  int CURSOR_HOT_SPOT_X = 10;
static const  int CURSOR_HOT_SPOT_Y = 35;
//static const uint PIXEL_FORMAT_ID   = wl_shm.format_.argb8888;

// ctx
static wayland_ctx* ctx;
static bool  done = false;

void 
on_button (uint button) {
    done = true;
}


struct
Wayland {
    pragma (inline,true):
    wl_display*  display ()                  { return (wl_display_connect (null)); }
    wl_display*  display (const char *name)  { return (wl_display_connect (name)); }  // name, NULL, from: env WAYLAND_DISPLAY, env WAYLAND_SOCKET, env XDG_RUNTIME_DIR
    wl_display*  display (int fd)            { return (wl_display_connect_to_fd (fd)); }
    wayland_ctx* ctx ()                      { return new wayland_ctx (); }
}

struct 
wayland_ctx {
    wl_display*       display;
    wl_registry*      registry;
    //wl_seat*          seat;
    //wl_compositor*    compositor;
    //wl_surface*       surface;
    //wl_shm*           shm;
    //wl_shell*         shell;
    //wl_shell_surface* shell_surface;
    //wl_shm_pool*      pool;
    //wl_buffer*        buffer;

    xdg_wm_base*   xdg_wm_base;

    //.xdg_surface*   xdg_surface;
    //.xdg_toplevel*  xdg_toplevel;
    //.buffer[2]      buffers;
    Input          input;

    struct 
    Frame_callback {
        //wl_callback*                 _wl_callback;
        void function (void*, void*)  user_callback;
        void*                         data;
    }
    Frame_callback frame_callback;

    int width, height;

    void* user_ctx;

    struct 
    Input {
        int         repeat_fd;

        //wl_keyboard* keyboard;
        //wl_pointer*  pointer;
        //wl_touch*    touch;

        //pointer_event pointer_event;
        //touch_event   touch_event;
        //xkb           xkb;

        //xkb_keysym_t sym;
        //uint         code;
        //uint         modifiers;

        //xkb_keysym_t repeat_sym;
        //uint         repeat_key;

        //int          repeat_rate_sec;
        //int          repeat_rate_nsec;
        //int          repeat_delay_sec;
        //int          repeat_delay_nsec;

        //struct 
        //Notify {
        //    key = void function (wl_keyboard_key_state state, xkb_keysym_t sym, uint code);
        //}
        //Notify notify;

        int key_pending;
    }
};

auto min (A,B) (A a, B b) { return (a) < (b) ? (a) : (b); }
auto max (A,B) (A a, B b) { return (a) > (b) ? (a) : (b); }


auto
wl_display_get_registry (wl_display* display) {
    return
        cast (wl_registry*) (
            wl_proxy_marshal_constructor (
                cast (wl_proxy*) display, 
                display_opcode_get_registry, 
                &wl_registry_interface, 
                null
            )
        );
}

extern (C)
void 
global_impl (void* ctx, wl_registry* _this, uint name, const(char)* interface_, uint version_) {
    printf ("%d: %s\n", name, interface_);
    auto xdg_wm_base_interface_name = "xdg_wm_base";
    if (strcmp (xdg_wm_base_interface_name.ptr, interface_) == 0) {
        xdg_wm_base_interface;

        (cast (wayland_ctx*) ctx).xdg_wm_base = 
        cast (xdg_wm_base*) 
            _this.bind (
                name, 
                //
                xdg_wm_base_interface, 
                version_
            );
    }
}
extern (C) 
void 
global_remove_impl (void* data, wl_registry* _wl_registry, uint name) {
    //
}


int
main () {
    //version (Dynamic) loadWaylandClient ();

    printf ("%s:, %d, %d\n", 
        wl_registry_interface.name, 
        wl_registry_interface.method_count,
        wl_registry_interface.event_count);
    printf ("%s:, %d, %d\n", 
        wl_shm_interface.name, 
        wl_shm_interface.method_count,
        wl_shm_interface.event_count);

    auto wayland  = Wayland ();
         ctx      = wayland.ctx ();

    // setup
    ctx.display  = wayland.display;
    ctx.registry = wl_display_get_registry (ctx.display);
    writeln (1, ": display         : ", ctx.display);
    writeln (1, ": registry        : ", ctx.registry);
    //ctx.registry.add_listener (&ctx.registry.listener,ctx);  // wl_proxy.add_listener
    ctx.registry.add_listener (
        new wl_registry.Listener (  // is a vector of function pointers. 
            &global_impl,
            &global_remove_impl,
        ),
        ctx);  // wl_proxy.add_listener
    //ctx.display.flush ();
    writeln (2);
    ctx.display.roundtrip ();
    writeln (3);
    ctx.registry.destroy ();
    ctx.display.disconnect ();

    if (ctx.shell is null) {
        printf ("Can't find shell\n");
        return EXIT_FAILURE;
    } 
    else {
        printf ("Found shell\n");
    }


    version (NEVER) {
    auto surface       = ctx.compositor.create_surface ();
    auto shell_surface = ctx.shell.get_shell_surface (surface);
    shell_surface.set_toplevel ();

    //
    auto image = open ("images.bin", O_RDWR);

    if (image < 0) {
        perror ("Error opening surface image");
        return EXIT_FAILURE;
    }

    printf ("%d\n", 1);
    ctx.pool    = hello_create_memory_pool (ctx.shm,image);
    printf ("%d\n", 2);
//    ? shell
    ctx.shell_surface = hello_create_surface (ctx.compositor,ctx.shell);
    printf ("%d\n", 3);
    ctx.buffer  = hello_create_buffer (ctx.pool,WIDTH,HEIGHT);
    printf ("%d\n", 4);
              hello_bind_buffer (ctx.buffer,ctx.shell_surface);
    printf ("%d\n", 5);
              hello_set_cursor_from_pool (ctx.pool,ctx.compositor,ctx.input.pointer,CURSOR_WIDTH,CURSOR_HEIGHT,CURSOR_HOT_SPOT_X,CURSOR_HOT_SPOT_Y);
    printf ("%d\n", 6);
              hello_set_button_callback (ctx.shell_surface,&on_button);
    printf ("%d\n", 7);

    //
    while (!done) {
        printf ("%d\n", 8);
        if (ctx.display.dispatch () < 0) {
            printf ("loop: dispatch 1\n");
            perror ("Main loop error");
            done = true;
        }
    }

    printf ("Exiting sample wayland client...\n");

    //
    //hello_free_cursor();
    //hello_free_buffer(buffer);
    //hello_free_surface(surface);
    //hello_free_memory_pool(pool);
    //close(image);
    //hello_cleanup_wayland();
}

    // cleanup
    //ctx.registry.destroy ();
    //ctx.display.disconnect ();

    return EXIT_SUCCESS;
}

//void 
//main () {
//	// INIT
//    auto wayland   = Wayland ();

//    auto c         = wayland.connect (false,null);
//    auto screen    = c.screen;
//    auto window    = c.window (screen);

//    writeln ("width x height (in pixels): ", screen.width_in_pixels, "x", screen.height_in_pixels);
//    writeln ("hwnd: ",window);

//    // EVENT LOOP
//    foreach (event; c.events) {
//        switch (event.type) {
//            case Event.Type.KEY_PRESS   : 
//            case Event.Type.KEY_RELEASE : 
//                writeln (event.keyboard);
//                break;
//            case Event.Type.BUTTON_PRESS   : 
//            case Event.Type.BUTTON_RELEASE : 
//                writeln (event.button);
//                break;
//            case Event.Type.MOTION_NOTIFY : 
//                writeln (event.motion);
//                break;
//            case Event.Type.EXPOSE : 
//                writeln (event.expose);
//                break;
//            default : writeln (event);
//        }        
//    }

//    c.disconnect ();
//}


version (NEVER):
struct 
pool_data {
    int      fd;
    typeof (stat_t.st_size) capacity;
    typeof (stat_t.st_size) size;
    pixel*   memory;
};
alias uint pixel;


Shm_pool
hello_create_memory_pool (Shm shm, int file) {
    Shm_pool  pool;
    stat_t   _stat;

    if (fstat (file, &_stat) != 0)
        return cast (Shm_pool) null;

    auto data = new pool_data (file,_stat.st_size,0);

    data.memory = cast (pixel*)
        mmap (null, data.capacity, PROT_READ, MAP_SHARED, data.fd, 0);

    if (data.memory == MAP_FAILED)
        goto cleanup_alloc;

    pool = shm.create_pool (data.fd, data.capacity.to!int);

    if (pool == null)
        goto cleanup_mmap;

    pool.set_user_data (data);

    return pool;

cleanup_mmap:
    munmap (data.memory, data.capacity);
cleanup_alloc:
    free (data);
    return cast (Shm_pool) null;
}

extern (C)
static 
void 
shell_surface_ping (void *data, wl_shell_surface* shell_surface, uint serial) {
    wl_shell_surface_pong (shell_surface, serial);
}

extern (C)
static 
void 
shell_surface_configure (void *data, wl_shell_surface *shell_surface, uint edges, int width, int height) { }

static 
const shell_surface_listener = wl_shell_surface_listener (
    ping      : &shell_surface_ping,
    configure : &shell_surface_configure,
);

Shell_surface
hello_create_surface (Compositor compositor, Shell shell) {
    auto surface = compositor.create_surface ();
    printf ("%d\n", 10);

    if (surface is null)
        return cast (Shell_surface) null;

    printf ("%p\n", shell._super);
    auto shell_surface = shell.get_shell_surface (surface);
    printf ("%d\n", 11);

    if (shell_surface is null) {
        surface.destroy ();
        return cast (Shell_surface) null;
    }


    shell_surface.add_listener (&shell_surface_listener,null);
    shell_surface.set_toplevel ();
    shell_surface.set_user_data (surface);
    surface.set_user_data (null);

    return shell_surface;
}

Buffer
hello_create_buffer (Shm_pool pool, uint width, uint height) {
    auto pool_data = cast (pool_data*) pool.get_user_data ();
    auto buffer    = pool.create_buffer (
        pool_data.size.to!int, width, height,
        width*pixel.sizeof.to!int, PIXEL_FORMAT_ID);

    if (buffer is null)
        return cast (Buffer) null;

    pool_data.size += width*height*pixel.sizeof;

    return buffer;
}

void 
hello_bind_buffer (Buffer buffer, Shell_surface shell_surface) {
    auto surface = cast (Surface) cast (wl_surface*) shell_surface.get_user_data ();
    surface.attach (buffer,0,0);
    surface.commit ();
}

struct 
pointer_data {
    Surface surface;
    Buffer  buffer;
    int     hot_spot_x;
    int     hot_spot_y;
    Surface target_surface;
}

void 
hello_set_cursor_from_pool (Shm_pool pool, Compositor compositor, Pointer pointer, uint width, uint height, int hot_spot_x, int hot_spot_y) {
    auto data = new pointer_data ();
    data.hot_spot_x = hot_spot_x;
    data.hot_spot_y = hot_spot_y;
    data.surface    = compositor.create_surface ();

    if (data.surface is null)
        goto cleanup_alloc;

    data.buffer = hello_create_buffer (pool,width,height);

    if (data.buffer is null)
        goto cleanup_surface;

    printf ("%p\n", pointer._super);
    if (pointer) pointer.set_user_data (data);

    return;

cleanup_surface:
    data.surface.destroy ();
cleanup_alloc:
    free (data);
error:
    perror ("Unable to allocate cursor");
}

void 
hello_set_button_callback (Shell_surface shell_surface, void function (uint) callback) {
    auto surface = cast (Surface) cast (wl_surface*) shell_surface.get_user_data ();
    surface.set_user_data (callback);
}

void 
hello_cleanup_wayland () {
    ctx.input.pointer.destroy ();
    ctx.seat.destroy ();
    ctx.shell.destroy ();
    ctx.shm.destroy ();
    ctx.compositor.destroy ();
    ctx.display.disconnect ();
}


//struct 
//wl_proxy {
//    wl_object            object;
//    wl_display*          display;
//    wl_event_queue*      queue;
//    uint32_t             flags;
//    int                  refcount;
//    void*                user_data;
//    wl_dispatcher_func_t dispatcher;
//    uint32_t             version_;
//    const char**         tag;
//};
//
//struct 
//wl_display {
//    wl_proxy       proxy;
//    wl_connection* connection;
//
//    /* errno of the last wl_display error */
//    int            last_error;
//
//    /* When display gets an error event from some object, it stores
//     * information about it here, so that client can get this
//     * information afterwards */
//    struct 
//    Protocol_error {
//        /* Code of the error. It can be compared to
//         * the interface's errors enumeration. */
//        uint32_t            code;
//        /* interface (protocol) in which the error occurred */
//        const wl_interface* interface;
//        /* id of the proxy that caused the error. There's no warranty
//         * that the proxy is still valid. It's up to client how it will
//         * use it */
//        uint32_t            id;
//    };
//    Protocol_error  protocol_error;
//    int             fd;
//    wl_map          objects;
//    wl_event_queue  display_queue;
//    wl_event_queue  default_queue;
//    pthread_mutex_t mutex;
//
//    int             reader_count;
//    uint32_t        read_serial;
//    pthread_cond_t  reader_cond;
//}

